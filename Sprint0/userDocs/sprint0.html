<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<!--
<script type="text/javascript" src="../css/issStyle.js"></script>
-->
<link rel="stylesheet" type="text/css" href="resources/css/sprint0.css">

<head>

    <title>Sprint0</title></head>

<body>
<!--
<div id="top">
    <h1><b>PROGETTO DI INGEGNERIA DEI SISTEMI SOFTWARE</b> - SPRINT 0 <font size="5"></font></h1>
    <h3>Gruppo di lavoro: Focardi, Galeone, Porrazzo <font size="3"></font></h3>
</div>
-->
<div class="body">
    <h2>Introduction</h2>
    <div class="remark"> Progetto finale di ISS, finalizzato allo sviluppo software di un magazzino refrigerato, nel
        quale
        vi &egrave; un robot che ha il compito di trasportare del cibo da un punto di partenza - chiamato INDOOR - alla cella
        frigorifera.
    </div>

    <h2>Requirements</h2>
    <div class="remark">
        <a href="https://htmlpreview.github.io/?https://github.com/anatali/issLab23/blob/main/iss23Material/html/TemaFinale23.html">Tema Finale </a>
    </div>

    <h2>Requirement analysis</h2>
    <div class="remark">
        <h3>Formalizzazione dei requisiti</h3>
        Per la formalizzazione dei requisiti verr&agrave; usato il linguaggio Kotlin.<br>
        D'altra parte, alcuni requisiti introducono un <i>abstraction gap</i>, per il quale non bastano i costrutti
            dei
            linguaggi di programmazione pi&ugrave; diffusi. Per questo motivo, la nostra software house ha creato su misura il
            <b class="ks">QActor meta-model</b> (QAK) per
            soddisfare questi requisiti. La documentazione di questo meta-model si trova a questo indirizzo:
        <a href="https://htmlpreview.github.io/?https://github.com/anatali/issLab23/blob/main/iss23Material/html/QakActors23.html">QActor meta-model</a>

        <!--------------SERVICE AREA-------------------------->
        <h4>Service Area</h4>
        Stanza rettangolare piana di dimensioni note, priva di ostacoli interni e delimitata da pareti solide.
        All'interno della
        stanza troviamo una
        <bc>INDOOR port</bc>
        , dalla quale viene prelevato il cibo, e una
        <bc>ColdRoom</bc>
        , nella quale viene depositato il cibo.
        Possiamo formalizzare le dimensioni della stanza con due valori
        <kc>serviceAreaLength</kc>
        e
        <kc>serviceAreaWidth</kc>
        , che rappresentano rispettivamente la lunghezza e la larghezza della stanza.
        <pre>
        <key>val</key> serviceAreaLength :  Float
        <key>val</key> serviceAreaWidth   :  Float</pre>

        <!--------------COLD ROOM-------------------------->
        <h4>ColdRoom</h4>
        Stanza refrigerata che ha l'obiettivo di tenere al fresco il cibo che il robot deposita. La stanza pu&ograve; contenere
        fino a <b>MAXW</b> kg di cibo.
        Possiamo formalizzare la capacit&agrave; della stanza con
        <ul>
            <li> una costante
                <kc>MAXW</kc>
                , che rappresenta il peso massimo che la stanza pu&ograve; contenere.
            </li>
            <li> una variabile
                <kc>coldRoomCurrentWeight</kc>
                , che rappresenta il peso attuale di cibo contenuto nella stanza.
            </li>
        </ul>

        <pre>
        <key>val</key> MAXW :  Double
        <key>var</key> coldRoomCurrentWeight : Double</pre>

<<<<<<< Updated upstream

    <!--------------DDR ROBOT-------------------------->
    <h4>DDR Robot</h4>
    Il Differential Drive Robot &egrave; un robot fisico che esegue le seguenti operazioni:
    <ul>
        <li>si muove avanti e indietro in linea retta</li>
        <li>si ferma</li>
        <li>ruota di 90&deg; a destra o a sinistra</li>
    </ul>
    Queste azioni sono eseguite alla ricezione dei relativi comandi da parte del sistema.
    Il cliente fornisce software capace di interfacciare il DDR robot con altri robot (reali o virtuali): <a href="https://github.com/anatali/issLab23/tree/main/unibo.basicrobot23">unibo.basicrobot23</a>.
    L'attore QAK <a href="https://github.com/anatali/issLab23/blob/main/unibo.basicrobot23/src/basicrobot.qak">basicrobot.qak</a> di unibo.basicrobot23 &egrave; in grado di interfacciarsi con il DDR robot e di
    eseguire i comandi di movimento e rotazione.


        Il componente <span class="blue">basicrobot</span> viene visto dall'esterno come un servizio che realizza un insieme di funzionalit&agrave;:
        <ul class="arabic simple">
            <br>
            <li>Esecuzione di richieste di <span class="brown">ingaggio</span>:
                <pre><span class="high">Request engage : engage(CALLER)
Reply   engagedone    : engagedone(ARG)
Reply   engagerefused : engagerefused(ARG)
Dispatch disengage    : disengage(ARG)</span></pre>
            </li>
            <li>Esecuzione di <span class="brown">comandi elementari</span> di movimento: <pre><span class="high">Dispatch cmd : cmd(MOVE)
Dispatch end : end(ARG)</span></pre></p>
            </li>
            <li>Esecuzione di <span class="brown">step</span> (movimento in avanti per un tempo dato): <pre><span class="high">Request step:step(TIME)
Reply stepdone : stepdone(V)
Reply stepfailed : stepfailed(DURATION, CAUSE)</span></pre></p></li>
            <li>Esecuzione di <span class="brown">sequenze di movimento</span> (piani): <pre><span class="high">Request doplan:doplan(PATH,STEPTIME)
Reply doplandone : doplandone(ARG)
Reply doplanfailed : doplanfailed(ARG)</span></pre></p></li>
            <li>Esecuzione di <span class="brown">posizionamento</span>: <pre><span class="high">Request moverobot:moverobot(TARGETX, TARGETY)
Reply moverobotdone : moverobotok(ARG)
Reply moverobotfailed : moverobotfailed(PLANDONE, PLANTODO)</span></pre></p></li>
        </ul>


        <!--------------TRANSPORT TROLLEY-------------------------->
        <h4>Transport Trolley</h4>
        Il carrello di trasporto &egrave; un'entit&agrave; software che deve interagire con il robot DDR. A tal fine,
        il carrello di trasporto deve interfacciarsi con il basicrobot.
        Il carrello di trasporto deve essere in grado di eseguire le stesse azioni del robot DDR, tuttavia il software
        fornito dal cliente in unibo.basicrobot23 &egrave; un attore, e come tale non prevede il concetto di ereditariet&agrave;,
        quindi il carrello di trasporto non pu&ograve; essere formalizzato utilizzando l'ereditariet&agrave;.
        <br>
        Il trasport trolley ha la forma di un quadrato con dimensione del lato prefissata <b>RD</b>
        <br>
        Il trasport trolley pu&ograve; essere modellato come modello Qak:
        <pre>
Dispatch pickingup : pickingup(_)
Dispatch droppingout : droppingout(MATERIAL)
Dispatch backhome : backhome(_)

QActor transporttrolley context ctxtransporttrolley {

    State s0 initial{
        ...
    }
    Goto idle

    State idle{
        ...
    }
    Transition t0 whenMsg pickingup -> pickup

    State pickup{
        ...
    }
    Transition t0 whenMsg droppingout -> dropout

    State dropout{
        ...
    }
    Transition t0 whenMsg backhome -> backhome
                        whenMsg pickingup -> pickup

    State backhome{
        ...
    }
    Goto idle
        </pre>
        <br>
        Per verificare il corretto funzionamento del carrello di trasporto e capire meglio qual &egrave; il comportamento atteso,
        abbiamo preparato alcuni semplici test ( <a href="">TestTransportTrolleyActor.kt</a> ).

=======
>>>>>>> Stashed changes
        <!--------------SEQUENZA OPERATIVA-------------------------->
        <h4>Sequenza operativa</h4>
        Rappresenta le azioni che deve compiere il <bc>Transport trolley</bc>, che inizialmente &egrave; situato in <bc>HOME</bc>:
        <ol>
            <br>
            <li>Prendere un carico di cibo da un camion situato alla <bc>INDOOR</bc></li>
            <li>Spostarsi dalla <bc>INDOOR</bc> alla <bc>PORT</bc> della <span class="blue" >ColdRoom</span class="blue"> </li>
            <li>Depositare il carico di cibo nella <span class="blue" >ColdRoom</span class="blue"> </li>
            <br>
        </ol>
        La fase di trasporto del carico di cibo pu&ograve; essere divisa in due fasi:
        <ul>
            <br>
            <li>Fase di <kc>PickingUp</kc>, in cui il robot preleva il carico dal camion, quindi si muove verso la indoor</li>
            <li>Fase di <kc>DroppingOut</kc>, in cui il robot si muove verso la Port della ColdRoom e deposita il carico al suo interno</li>
        </ul>
<<<<<<< Updated upstream

=======
        Considerando che il driver deve rimuovere il suo furgone il più velocemente possibile dalla <kc>Indoor</kc>, le due fasi possono essere formalizzate rispettivamente attraverso una<kc>Request-response Qak</kc> e un <kc>Dispatch</kc>:
        <pre>
Request pickup : pickup(Ticet.TICKETID)
            <!--TODO controllare se noi abbiamo argomenti all'interno-->
            <!--Si dovrebbe avere come argomento il ticketid relativo allo scarico ?-->
Dispatch dropout: dropout(_)

Reply chargeTaken: chargeTaken(_)
        </pre>

>>>>>>> Stashed changes
        <!--------------SONAR------------------------->
        <h4>Sonar</h4>
        Rappresenta l'astrazione del sensore fisico 'HC-SR04'. Il cliente ci ha gi&aacute; fornito in precedenza il software relativo al sonar, formalizzando il sonar come un attore <kc>Qak</kc> <a href="https://github.com/anatali/issLab23/tree/main/unibo.sonarqak23">unibo.sonarqak23</a>.<br>
        Il software emette evneti a seconda della distanza, inoltre &egrave; possibile usare i comandi <bc> Dispatch </bc>per attivare o disattivare il sonar.
        <pre>
Dispatch sonaractivate     : info(ARG)
Dispatch sonardeactivate   : info(ARG)
Event sonar               : distance(V)
        </pre>

        Inserire qui l'architettura
        <br>
         L'attore <bc>distanceFilter</bc> filtra e invia al prossimo attore eventi di tipo ostacolo: l'evento viene creato solo quando la distanza 'filtrata' rilevata &egrave; minore di una distanza fissa predefinita <kc>DLIMT</kc>.
        <pre>
Event obstacle  :  obstacle(distance)
        </pre>

        <!--------------LED-------------------------->
        <div id="led">
        <h4>Led</h4>
        Il Led &egrave; un dispositivo di output presente nel RaspberryPi; le azioni che pu&oacute; compiere sono:
        <ul>
            <br>
            <li>Led Off: quando il Transport Trolley &egrave; in HOME</li>
            <li>Led On: quando il Transport Trolley &egrave; fermo </li>
            <li>Led Blink: quando il Transport Trolley si sta muovendo</li>
            <br>
        </ul>
        Il cliente ci ha fornito in precedenza il software per il Led: <a href="https://github.com/anatali/issLab23/tree/main/unibo.radarsystemqak23">it.unibo.radarRystem23</a> <br>
        Il comportamento del Led pu&oacute; essere espresso tremite un attore Qak:
        <pre>
Dispatch turnOn : turnOn(_)
Dispatch turnOff : turnOff(_)
Dispatch blink : blink(_)

QActor ledqakactor context ctxledqak {

    State setup initial {
        println("$name | setup")
    }Goto off

    State on {
        ...
    }
    Transition t0 whenMsg blink -> blink
                    whenMsg turnOff -> off


    State off{
        ...
    }
    Transition t0 whenMsg turnOn -> on
                    whenMsg blink -> blink


    State blink{
        ...
    }
    Transition t0 whenMsg turnOn -> on
                    whenMsg turnOff -> off
}
        </pre>
        </div>
        <!--------------MINT -------------------------->
        <h4>MINT </h4>
        Valore prefissato per il quale il trolley in movimento non pu&ograve; essere fermato nuovamento dopo uno stop antecedente.
        <pre>
val MINT : Float
        </pre>

        <!--------------DLIMT-------------------------->
        <h4>DLIMT</h4>
        Valore per cui il Transport Trolley deve fermarsi se la distanza rilevata dal Sonar &egrave; minore di DLIMT. Il Transport Trolley verr&agrave; riattivato una
        volta che il sonar rilevi una distanza maggiore di DLIMT.
        <pre>
val DLIMT : Float
        </pre>

        <!--------------FW-------------------------->
        <h4>FW</h4>
        Rappresenta il peso in chilogrammi, che si intende depositare nella ColdRoom.
        <pre>
var FW :  Float
        </pre>

        <!--------------ServiceAccessGUI-------------------------->
        <h4>ServiceAccessGUI</h4>
        La ServiceAccessGui &egrave; un' interfaccia grafica che consente a una persona di osservare il peso corrente del cibo immagazzinato all'interno
        della <kc>ColdRoom</kc> e di inviare messaggi al <kc>ColdStorageService</kc> per immagazzinare un nuovo carico di <b>FW</b> kg di cibo.
        <pre>
<key>val</key> FW : Double
        </pre>
        Se la richiesta &egrave; accetta il servizio assegna un ticket che scade dopo un periodo prefissato <b>TICKETTIME</b> secs.
        <pre>
<key>val</key> TICKETTIME : Int
        </pre>
        e fornisce un campo per immettere il numero del ticket quando un furgone si trova presso l' <kc>INDOOR</kc>
        <!--------------Ticket-------------------------->
        <h4>Ticket</h4>
        Il ticket &egrave; rappresenta l'oggetto restituito dalla <kc>ServiceAccessGUI</kc>, al momento di arrivo di un nuovo furgone.<br>
        Possiede due campi:
        <pre>
<key>val</key> TICKETID : Int
<key>val</key> TICKETTIME : Int
        </pre>

        <!--------------Stato corrente del Transport Trolley-------------------------->
        <h4>Stato corrente del Transport Trolley</h4>
        Indica lo stato del <a href="#Ttrolley"><kc>Transport Trolley</kc></a>, pu&oacute; essere formalizzato come un enumerativo <a href="">TransportTrolleyState.kt</a>
        <pre>
enum class CurrStateTrolley { IDLE, STOPPED, MOVING, PICKINGUP, DROPPINGOUT }
        </pre>

        <!--------------Posizione del Transport Trolley-------------------------->
        <h4>Posizione del Transport Trolley</h4>
        Indica le varie posizione possibili del <a href="#Ttrolley"><kc>Transport Trolley</kc></a>, pu&oacute; essere formalizzato come un enumerativo <a href="">TransportTrolleyPosition.kt</a>
        <pre>
enum class TTPosition { HOME, INDOOR, PORT }
        </pre>

        <!--------------Stato del Led-------------------------->
        <h4>Stato corrente del Led</h4>
        Indica i vari stati che il <a href="#led"><kc>Led</kc></a> pu&oacute; assumere: On, Blinking, Off .Pu&oacute; essere formalizzato come un enumerativo <a href="">LedState.kt</a>
        <pre>
enum class CurrStateLed { ON, OFF, BLINKING }
        </pre>

        <!--------------Richiesta di deposito-------------------------->
        <h4>Richiesta di deposito</h4>
        Rappresenta la richiesta che un driver pu&oacute; effettuare attraverso la <kc>ServiceAccessGUI</kc> che viene processata dallo <kc>ColdStorageService</kc>.
        Per formalizzare la richiesta utilizziamo il linguaggio <kc>Qak</kc>:
        <pre>
Request storeFood : storeFood(FW)
        </pre>
        <!--------------Scarico consentito-------------------------->
        <h4>Scarico consentito</h4>
        Nel caso in cui <kc>ColdStorageService</kc>, a seguito di una <kc>Request storeFood</kc>, rispondesse in modo affermativo &egrave; possibile scaricare il cibo nella <kc>ColdRoom</kc>;in questo caso viene generato un <b>TICKET</b> che viene assegnato al driver.
        La formalizzazione di questo concetto può essere espressa attraverso il linguaggio Qak.
        <pre>
Reply storeAccepted : storeAccepted(Ticket)
        </pre>

        <!--------------Scarico non consentito-------------------------->
        <h4>Scarico non consentito</h4>
        Nel caso in cui <kc>ColdStorageService</kc>, a seguito di una <kc>Request storeFood</kc>, rispondesse in modo negativo, non &egrave; possibile scaricare il cibo nella <kc>ColdRoom</kc>.
        La formalizzazione di questo concetto pu&ograve; essere espressa attraverso il linguaggio Qak.
        <pre>
Reply storeRejected : storeRejected(_)
        </pre>

        <!--------------Cold Storage Service-------------------------->
        <h4>Cold Storage Service</h4>
       &Egrave; il servizio che coordina il deposito del cibo, interfacciandosi con il <kc>Transport Trolley</kc> per effettuare le azioni necessarie.<br>
        Per questo &egrave; un entit&aacute; <b>attiva</b> che deve essere in grado di ricevere richiesta ( <kc>storeFood</kc>)  e mandare risposte (<kc>storeAccepted</kc>, <kc>storeRejected</kc>).<br>
        Pu&oacute; essere formalizzato come un attore attraverso il linguaggio Qak ( <a href="">ColdStorageService.qak</a> ).
        <pre>
QActor coldStorageServiceActor context ctxStorageService {
        State setup initial {
            ...
        }
        Goto idle
        
        State idle {
            ...
        }
        Transition t0 whenRequest storeFood -> requestEvaluation
        
        State requestEvaluation {
            onMsg(storeFood : storeFood(FW)){
                
                if[# coldRoom.canStore(requestWeightToStore) #]
                {
                    ...
                    replyTo storeFood with storeAccepted : storeAccepted(Ticket)
                }
                else{
                    replyTo storeFood with storeRejected : storeRejected(_)
                } 
            }
        }
        Goto idle
    }
        </pre>
        Per verificare il corretto funzionamento del servizio, abbiamo implementato dei test (<a href="">TestColdStorageService.kt</a>).
        <pre>
var storeFood = "msg(storeFood, request, testunit, coldRoomServiceActor, storeFood(100),1)"
var asw = conn.request(storeFood)
assertTrue(asw.contains("storeAccepted"))

var storeFood = "msg(storeFood, request, testunit, coldRoomServiceActor, storeFood(1000),1)"      <!--TODO capire che cazzo &egrave; quell'1-->
var asw = conn.request(storeFood)
assertTrue(asw.contains("storeRejected"))
        </pre>


        <!--------------DDR ROBOT-------------------------->
        <h4>DDR Robot</h4>
        Il Differential Drive Robot &egrave; un robot fisico che esegue le seguenti operazioni:
        <ul>
            <li>si muove avanti e indietro in linea retta</li>
            <li>si ferma</li>
            <li>ruota di 90&deg; a destra o a sinistra</li>
        </ul>
        Queste azioni sono eseguite alla ricezione dei relativi comandi da parte del sistema.
        Il cliente fornisce software capace di interfacciare il DDR robot con altri robot (reali o virtuali): <a href="https://github.com/anatali/issLab23/tree/main/unibo.basicrobot23">unibo.basicrobot23</a>.
        L'attore QAK <a href="https://github.com/anatali/issLab23/blob/main/unibo.basicrobot23/src/basicrobot.qak">basicrobot.qak</a> di unibo.basicrobot23 &egrave; in grado di interfacciarsi con il DDR robot e di
        eseguire i comandi di movimento e rotazione.


        Il componente <span class="blue">basicrobot</span> viene visto dall'esterno come un servizio che realizza un insieme di funzionalit&agrave;:
        <ul class="arabic simple">
            <br>
            <li>Esecuzione di richieste di <span class="brown">ingaggio</span>:
                <pre><span class="high">Request engage : engage(CALLER)
Reply   engagedone    : engagedone(ARG)
Reply   engagerefused : engagerefused(ARG)
Dispatch disengage    : disengage(ARG)</span></pre>
            </li>
            <li>Esecuzione di <span class="brown">comandi elementari</span> di movimento: <pre><span class="high">Dispatch cmd : cmd(MOVE)
Dispatch end : end(ARG)</span></pre></p>
            </li>
            <li>Esecuzione di <span class="brown">step</span> (movimento in avanti per un tempo dato): <pre><span class="high">Request step:step(TIME)
Reply stepdone : stepdone(V)
Reply stepfailed : stepfailed(DURATION, CAUSE)</span></pre></p></li>
            <li>Esecuzione di <span class="brown">sequenze di movimento</span> (piani): <pre><span class="high">Request doplan:doplan(PATH,STEPTIME)
Reply doplandone : doplandone(ARG)
Reply doplanfailed : doplanfailed(ARG)</span></pre></p></li>
            <li>Esecuzione di <span class="brown">posizionamento</span>: <pre><span class="high">Request moverobot:moverobot(TARGETX, TARGETY)
Reply moverobotdone : moverobotok(ARG)
Reply moverobotfailed : moverobotfailed(PLANDONE, PLANTODO)</span></pre></p></li>
        </ul>


        <!--------------TRANSPORT TROLLEY-------------------------->
        <div id="tTrolley">
        <h4>Transport Trolley</h4>
        Il carrello di trasporto &egrave; un'entit&agrave; software che deve interagire con il robot DDR. A tal fine,
        il carrello di trasporto deve interfacciarsi con il basicrobot.
        Il carrello di trasporto deve essere in grado di eseguire le stesse azioni del robot DDR, tuttavia il software
        fornito dal cliente in unibo.basicrobot23 &egrave; un attore, e come tale non prevede il concetto di ereditariet&agrave;,
        quindi il carrello di trasporto non pu&ograve; essere formalizzato utilizzando l'ereditariet&agrave;.
        <br>
        Il trasport trolley ha la forma di un quadrato con dimensione del lato prefissata <b>RD</b>
        <br>
        Il trasport trolley pu&ograve; essere modellato come modello Qak:
        <pre>
Dispatch pickingup : pickingup(_)
Dispatch droppingout : droppingout(MATERIAL)
Dispatch backhome : backhome(_)

QActor transporttrolley context ctxStorageService {
            <!-- Il contesto non è relativo al coldStorageService? -->
            <!-- TODO vedere se inserire variabili-->
    [#
        val tTstate = transporttrolley.state.TransportTrolleyState(transporttrolley.state.CurrStateTrolley.IDLE)
    #]
    State s0 initial{
        ...
    }
    Goto idle

    State idle{
        ...
    }
    Transition t0 whenRequest pickup -> pickingup

    State pickingup{
        ...
            replyTo pickUp with chargeTaken : chargeTaken(_)
    }
    Transition t0 whenMsg dropout -> droppingout

    State dropout{
        ...
    }
    Transition t0 whenMsg backhome -> backhome
                        whenMsg pickingup -> pickup(Ticket.TICKETID)

    State backhome{
        ...
    }
    Goto idle
        </pre>
        <br>
        Per verificare il corretto funzionamento del carrello di trasporto e capire meglio qual &egrave; il comportamento atteso,
        abbiamo preparato alcuni semplici test ( <a href="">TestTransportTrolleyActor.kt</a> ).
</div>

    </div>
    <!----------User stories--------------------->
    <div class="remark">
        <h3> User stories </h3>
        Al fine di rendere le immagini relative alla descrizione delle User Stories
        pi&ugrave; comprensibili si riporta di seguito una legenda relativa ai simboli che verranno usati.
        <br><br>
        <!--<img src="./resources/draw/legenda.png" alt="legenda">-->

        <!-----------Store Food----------------->
        <h4>Store Food</h4>

        <!-----------Service Status Area----------------->
        <h4>Service Status Area</h4>

    </div>

    <h2>Problem analysis</h2>
<!--  TODO vagliare se rimuovere il titolo Problem Analysis  -->
    <!-- Bisogna fare così analisi del progetto -->
    <!--Naturalmente questo non &egrave; l’unico modo di procedere. Il lettore &egrave; invitato (come analista e/o come progettista) a individuare alternatve.-->
    <div class="remark">

        <h3>Archittettura Logica</h3>
        <!--<img src="./resources/" alt="architettura logica">-->

    </div>

<!--
    <h2>Test plans</h2>

    <div class="remark">

    </div>

    <h2>Project</h2>
    <div class="remark">

        

    </div>
</div>

<h2>Testing</h2>
<div class="remark">

</div>


<h2>Deployment</h2>
<div class="remark">

</div>


<h2>Maintenance</h2>
-->
<!-- USEFUL
<table style="width:100%" border="1">
<tr>
<td style="width:50%">
</td>
<td></td>
</tr>
</table>
-->

<br/><br/>
</div>

<div class="stud">
    By Students: <br>
    Name: Leonardo Focardi, Christian Galeone, Gianmiriano Porrazzo<br>
    Email: leonardo.focardi@studio.unibo.it, christian.galeone@studio.unibo.it, gianmiriano.porrazzo@studio.unibo.it <br>
    <!--
    <img src="./resources/boys/" alt="" width="8%" height="8%">
    <img src="./resources/boys/" alt="" width="8%" height="8%">
    -->
    <img src="./resources/boys/gian.jpg" alt="" width="8%" height="8%">
    GIT repo: https://github.com/LEOB3TA/issProject2023
</div>
</body>
</html>
