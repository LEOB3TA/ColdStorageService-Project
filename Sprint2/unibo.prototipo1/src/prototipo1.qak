System/* -trace*/prototipo1

// Messaggi scambiati con mocktruck 
Request deposit : deposit(_)
Request sendTicket : sendTicket(TICKETID)
Request storeFood : storeFood(FW)
Reply storeAccepted : storeAccepted(TICKETID) for storeFood
Reply storeRejected : storeRejected(_) for storeFood
Reply chargeTaken : chargeTaken(_) for deposit
Reply ticketValid : ticketValid(_) for sendTicket
Reply ticketNotValid : ticketNotValid(_) for sendTicket
Reply ticketExpired : ticketExpired(_) for sendTicket

// Messaggi scambiati con transporttrolley
Request pickup:    pickup(_) 
Reply  pickupdone:  pickupdone(_) for pickup

// Messaggi scambiati col basicrobot23

Request engage        : engage(ARG)
Reply   engagedone    : engagedone(ARG) for engage
Reply   engagerefused : engagerefused(ARG) for engage
Dispatch disengage    : disengage(ARG)

Request  doplan     : doplan( PATH, OWNER, STEPTIME )
Reply doplandone    : doplandone( ARG ) for doplan
Reply doplanfailed  : doplanfailed( ARG ) for doplan

Request moverobot    :  moverobot(TARGETX, TARGETY)
Reply moverobotdone  :  moverobotok(ARG) for moverobot
Reply moverobotfailed:  moverobotfailed(PLANDONE, PLANTODO) for moverobot

Dispatch setrobotstate: setpos(X,Y,D)
Dispatch setdirection : dir( D )  	  //D =up|down!left|right
Dispatch cmd       	: cmd(MOVE)		 //MOVE=w|s|d|a|r|l|h

Event local_movef : movef(_)

//Sonar
Event sonardata : distance(D) //dataclenaer
Event obstacle : obstacle(D)	//distancefilter
Event alarm		: alarm(X)		//per tt TODO: l'argomento � utile?
Event robotmoving : robotmoving(_)  
Event resume:resume(_)
Dispatch sonaractivate: info(D) //D = DLIMIT

//Led 
Dispatch ledCmd : ledCmd ( ON,OFF,BLINK )

Dispatch coapUpdate: coapUpdate(RES,VAL)

Context ctxbasicrobot ip [host="127.0.0.1" port=8020]
Context ctxprototipo1 ip [host="localhost" port=8099]
//Context ctxtruck ip[host="127.0.0.1" port=8092] //indirizzo interno alla rete

// Attori Esterni
ExternalQActor basicrobot context ctxbasicrobot
//ExternalQActor mocktruck context ctxtruck

//Sonar

//CodedQActor sonar  context ctxrasp className "rx.sonarHCSR04Support23"   //SU RASP
CodedQActor sonar context ctxprototipo1 className "rx.sonarSimulator" //in LOCALE
CodedQActor datacleaner    context ctxprototipo1 className "rx.dataCleaner"
CodedQActor distancefilter context ctxprototipo1 className "rx.distanceFilter"


QActor mocktruck context ctxprototipo1{
    [#
       	var FW = 0
        var DT = 1000L  //DT= driver time tempo che ci mette il driver dopo aver ricevuto la richiesta per arrivare alla INDOOR
        var TICKETID = 0
        val truckstate = resources.truckstate.TruckState()

        fun initDriver(){
        	FW =  kotlin.random.Random.nextInt(1, 101)
        	DT = kotlin.random.Random.nextLong(1, 5001)
        }
    #]
    State s0 initial{
		println("$name |	started") color green
		println("this is an infinite loop, you need to kill the program to stop this") color red
		discardMsg Off

    }Goto idle

    State idle {
        println("$name |	in idle") color green
        [#
        	initDriver()
        	delay(kotlin.random.Random.nextLong(1, 15001))
        #]
    }Goto sendStore

    State sendStore {
    	 println("$name |	sendStore") color green
        request coldstorageservice -m storeFood : storeFood($FW)

    } Transition t0 whenTime 60000 -> handleError //se non arriva una risposta entro 60 secondi c'è un errore interno al sistema, il driver abbandona
    whenReply storeAccepted -> accepted
                    whenReply storeRejected -> rejected

   State rejected{
   		printCurrentMessage
   		println("$name |	request rejected") color green
   }Goto idle

    State accepted{
   		printCurrentMessage
   		onMsg (storeAccepted : storeAccepted(TICKETID)){
   		[#
   			TICKETID = payloadArg(0).toInt()
   		#]
   		}

   		println("$name |	request accepted") color green
   }Transition t0 whenTimeVar DT -> sendTicket

   State sendTicket{
   		 request coldstorageservice -m sendTicket : sendTicket($TICKETID)
   		 println("$name |	send ticket") color green
   } Transition t0 whenTime 60000 -> handleError //se non arriva una risposta entro 60 secondi c'� un errore interno al sistema, il driver abbandona
   					whenReply ticketValid -> sendDeposit
    				whenReply ticketExpired -> handleTicketExpired


    State sendDeposit{
        request coldstorageservice -m deposit : deposit(_)
        println("$name |	send deposit") color green
    } Transition t0  whenTime 60000 -> handleError //se non arriva una risposta entro 60 secondi c'� un errore interno al sistema, il driver abbandona
    					whenReply chargeTaken -> idle

    State handleError{
    	println("$name |	COLD STORAGE SERVICE ERROR") color red
    } Goto idle

	State handleTicketExpired{
		println("$name |	ticket expired") color green
	} Goto idle

	State handleTicketNotValid{
		println("$name |	ticket Not valid retry") color green
	} Goto sendTicket

}

QActor coldstorageservice context ctxprototipo1 {

 	[#
        	val MAXW = resources.ColdStorageService.getMAXW()
			val TICKETTIME = resources.ColdStorageService.getTICKETTIME()
		   	var currentWeightStorage = resources.ColdStorageService.getCurrentWeightStorage()
		   	var requestWeightToStore = 0.0
		   	var TICKETNUMBER = resources.ColdStorageService.getTicketNumber()
		   	#]

    State setup initial {
        	println("$name |	setup") color blue
        	discardMsg Off

    }

  Goto idle

    State idle {
        println("$name |	in idle") color green
    }
    Transition t0 whenRequest storeFood -> requestEvaluation
    			  whenRequest sendTicket -> ticketEvaluation
    			  whenRequest deposit -> charged
    			  whenReply pickupdone -> taken
    			  whenEvent local_movef -> error

    /*
     *  REQUEST EVALUATION
     *  1. Funzione canStore gestisce la logica
     * 	2a. Se esito positivo, va in stato acceptRequest
     * 	2b. Altrimenti va in stato rejectRequest
     */
    State requestEvaluation {
    	        onMsg(storeFood : storeFood(FW)){
           println("Request evaluation to store ${payloadArg(0)} kg") color blue
           [#requestWeightToStore=payloadArg(0).toDouble()#]

       }
    } Goto acceptRequest if[# resources.ColdStorageService.canStore(requestWeightToStore) #]
                            else rejectRequest

     /*
      *  ACCEPT REQUEST
      *  Generazione TICKET +
      */
     State acceptRequest{
    	[#
    		TICKETNUMBER = resources.ColdStorageService.getTicketNumber()
    		var TICKET : resources.model.Ticket = resources.model.Ticket(TICKETNUMBER, TICKETTIME)
    		resources.ColdStorageService.incrementTicketNumber()
    		resources.ColdStorageService.getTicketList().add(TICKET)
    	#]
        replyTo storeFood with storeAccepted : storeAccepted($TICKETNUMBER) 
    }Goto idle

	/*
	 *  REJECT REQUEST
	 */
    State rejectRequest{
        replyTo storeFood with storeRejected : storeRejected(_)
    }Goto idle

    /* Non usato
     State dropout{
    	forward transporttrolley -m dropout : dropout(FW)
    	forward transporttrolley -m gotohome : gotohome(_)
	}Goto idle
*/

    State charged{
    	println("$name |	in charged") color green
    	request transporttrolley -m pickup : pickup(_)
    }Goto idle

    State taken{
    	println("$name |	in taken") color green
    	replyTo deposit with chargeTaken : chargeTaken(_)
    }Goto idle



    /*
	 *  TICKET EVALUATION
	 *  Il coldStorageService controlla se il ticket ricevuto in input � uguale a quello che si aspetta.
	 * 	In caso di errore, il truck pu� riprovare ad inserire il numero del ticket fin quando non scade il TICKETTIME.
	 *
	 */
    State ticketEvaluation {
		 onMsg(sendTicket : sendTicket(TICKETID)){
		 	println("Ticket evaluation of ticket id ${payloadArg(0)}") color blue
    	        	[#
    	        		 val TICKETID = payloadArg(0).toInt()
    	         	 val TICKETEVALUATION = resources.ColdStorageService.evaluateTicket(TICKETID) #]
    	        	if [#TICKETEVALUATION == resources.TicketEvaluationResponse.VALID #] {
    	        		[#
    	        			val TICKET = resources.ColdStorageService.getTicketById(TICKETID)
							resources.ColdStorageService.getTicketList().remove(TICKET)
    	        		#]
    	        		replyTo sendTicket with ticketValid : ticketValid(_)
    	        	}
					if [#TICKETEVALUATION == resources.TicketEvaluationResponse.EXPIRED #] {
    	        		[#
    	        			 resources.ColdStorageService.incrementRejectedRequestCounter()
    	        			val TICKET = resources.ColdStorageService.getTicketById(TICKETID)
							resources.ColdStorageService.getTicketList().remove(TICKET)
    	        		#]
    	        		   println("Ticket of id ${payloadArg(0)} is expired - Reject Request") color blue
    						replyTo sendTicket with ticketExpired : ticketExpired(_)
    	        	}
					
					if [#TICKETEVALUATION == resources.TicketEvaluationResponse.INVALID #] {
    	        		[#
    	        			val TICKET = resources.ColdStorageService.getTicketById(TICKETID)
							resources.ColdStorageService.getTicketList().remove(TICKET)
    	        		#]
    	        			println("Inserted ticket id is not valid") color red
    					replyTo sendTicket with ticketNotValid : ticketNotValid(_)
    	        	}
					
       				}
    }Goto idle
    
   State error{
   	println("$name | robot failed to move") color red
 		emit local_movef : local_movef(_)
 		println("$name | close") color red
 		[# System.exit(0) #]
   }
}

QActor transporttrolley context ctxprototipo1{
	[#
		var CRX = 4;
		var CRY = 3;
		var INDOORX= 0;
		var INDOORY= 4;
		var HOMEX= 0;
		var HOMEY= 0;
		//println("$HOMEX,$HOMEY");
		var TICKETID = 0;
		val tTState = state.TransportTrolleyState();
		val MyName = name;
		//val MINT = 10
	#]
	State init initial{
		discardMsg Off
		// engage
		println("$name | request engage") color green
		request basicrobot -m engage : engage ($MyName, 320)
		updateResource[#tTState.toJsonString()#]
		//printCurrentMessage color black
	}Transition t0 //whenTime 10000 -> error
				   whenReply engagedone -> idle
				   whenReply engagerefused -> waitforfree

   State error{ //DEBUG
   		println("$name | basic robot error") color red
   		println("$name | disengaging....") color red
   		forward basicrobot -m disengage : disengage( $MyName )
   		println("$name | disengaged....") color red
   }

	State waitforfree{
		println("$name | already engaged") color green
	} Transition t0 whenTime 10000 -> idle

	State idle {
		println("$name | engaged") color green
		[#
			tTState.setCurrState(state.CurrStateTrolley.IDLE)
			tTState.setCurrPosition(state.TTPosition.HOME)
		#]
		updateResource[#tTState.toJsonString()#]
		// State print for debug
		//[#
		//	println(tTState.getCurrState())
		//	println(tTState.getCurrPosition())
		//#]
		forward basicrobot -m setrobotstate : setpos (0,0,d) // d= down
		println("$name | waiting for commands.") color green
  	}
 	Transition t0 whenRequest pickup -> moverobottoindoor

 	State moverobottoindoor {
 		//move robot to indoor
 		onMsg(pickup :pickup(_)){
 			[#
			tTState.setCurrState(state.CurrStateTrolley.PICKINGUP)
			tTState.setCurrPosition(state.TTPosition.INDOOR)
			#]
 		}
		updateResource[#tTState.toJsonString()#]
 		println("$name | moving robot to indoor.") color green
 		request basicrobot -m moverobot:moverobot($INDOORX,$INDOORY)
		
		emit robotmoving: robotmoving(_)
		
		onMsg(alarm: alarm(X)){
			// stop tt
			[#tTState.setCurrState(state.CurrStateTrolley.STOPPED)#]
			updateResource[#tTState.toJsonString()#]
			forward basicrobot -m cmd:cmd(h) //TODO sitemare e nuovo plan to
			//TODO: MINT per fermare nuovi stop 
		}
		
		onMsg(resume: resume(_)){
			[#tTState.setCurrState(state.CurrStateTrolley.MOVING)#]
			updateResource[#tTState.toJsonString()#]
			emit robotmoving: robotmoving(_)
			forward basicrobot -m cmd:cmd(r) //TODO :verificare comando per resume
		}
 	}
 	Transition t0 whenEvent alarm -> handlerobotstopped
 				whenReply moverobotdone -> movetoport
 				  whenReply moverobotfailed -> robotmovefailed //TODO controllare cosa accade in caso di emissione dell'evento alarm perchè non è da escludere che non funzioni
 				  
  	State handlerobotstopped{ //TODO aggiungere il fatto di MINT, capire in che stato deve andare dopo
  		[#tTState.setCurrState(state.CurrStateTrolley.STOPPED)#]
		updateResource[#tTState.toJsonString()#]
  		onMsg(moverobotfailed : moverobotfailed(PLANDONE,PLANTODO)){
  			[#val PLANTODO = payloadArg(1)#]
  		}
  		onMsg(resume: resume(_)){
  			[#tTState.setCurrState(state.CurrStateTrolley.MOVING)#]
			updateResource[#tTState.toJsonString()#]
			emit robotmoving: robotmoving(_)
			request basicrobot -m doplan:doplan($PLANTODO)
  		}
  	}


	//when robot has taken kg from camion -> move robot to coldroom
	State movetoport{
		[#
			tTState.setCurrState(state.CurrStateTrolley.MOVING)
			tTState.setCurrPosition(state.TTPosition.ONTHEROAD)
		#]
		updateResource[#tTState.toJsonString()#]
		//send event "robot is in indoor"
		println("$name | robot is in indoor") color green
		println("$name | moving robot to coldroom") color green
		// da usare col css
		replyTo pickup with pickupdone:pickupdone(_)
		request basicrobot -m moverobot:moverobot($CRX,$CRY)
		emit robotmoving: robotmoving(_)
		
		onMsg(alarm: alarm(X)){
			// stop tt
			[#tTState.setCurrState(state.CurrStateTrolley.STOPPED)#]
			forward basicrobot -m cmd:cmd(s) 			
		}
		onMsg(resume: resume(_)){
			[#tTState.setCurrState(state.CurrStateTrolley.MOVING)#]
			emit robotmoving: robotmoving(_)
			forward basicrobot -m cmd:cmd(r) 
		}
	}
	Transition t0 whenReply moverobotdone -> depositactionended
 				  whenReply moverobotfailed -> robotmovefailed

	State depositactionended{
		[#
			tTState.setCurrState(state.CurrStateTrolley.DROPPINGOUT)
			tTState.setCurrPosition(state.TTPosition.PORT)
		#]
		updateResource[#tTState.toJsonString()#]

		println("$name | robot is in coldroom") color green
		//emitlocal local_dropoutdone: local_dropoutdone
		println("$name | depositaction ended") color green
		println("$name | waiting for next move" ) color green
		[#
			tTState.setCurrState(state.CurrStateTrolley.IDLE)
			tTState.setCurrPosition(state.TTPosition.PORT)
		#]
		updateResource[#tTState.toJsonString()#]
	}
	Transition t0 whenTime 3000 -> robottohome
	whenRequest pickup -> moverobottoindoor
	//se arriva un messagio prima di 3s moverobottoindoor altrimenti torno in home opppure se c'� gi� una pickup in coda

	State robottohome{
		[#
			tTState.setCurrState(state.CurrStateTrolley.MOVING)
			tTState.setCurrPosition(state.TTPosition.ONTHEROAD)
		#]
		updateResource[#tTState.toJsonString()#]
		//send event "robot is in home"
		request basicrobot -m moverobot:moverobot($HOMEX,$HOMEY)
		emit robotmoving: robotmoving(_)
		
		onMsg(alarm: alarm(X)){
			// stop tt
			[#tTState.setCurrState(state.CurrStateTrolley.STOPPED)#]
			forward basicrobot -m cmd:cmd(s) 			
		}
		onMsg(resume: resume(_)){
			[#tTState.setCurrState(state.CurrStateTrolley.MOVING)#]
			emit robotmoving: robotmoving(_)
			forward basicrobot -m cmd:cmd(r) 
		}
		
		delay 6300
		forward basicrobot -m cmd : cmd ( l )
		/*delay 6500
		forward basicrobot -m setdirection : dir( DOWN )
		forward basicrobot -m setrobotstate : setpos (0,0,d) // d= down	*/
		println ("dir correction") color red
	}
	Transition t0 whenReply moverobotdone -> idle
 				  whenReply moverobotfailed -> robotmovefailed


 	//control failed robot moves
 	State robotmovefailed{
 		println("$name | robot failed to move") color red
 		emit local_movef : local_movef(_)
 		println("$name | close") color red
 		[# System.exit(0) #]
 	}

}

// Implementazione sonar 
//TODO: verificare in quale contesto si debba inserire, credo nello stesso contensto fino a quando non si mette nel rasp
//TODO: catch event alarm on tt and make it stop

QActor sonar23 context ctxprototipo1{
	State s0 initial{
		[#var Appl = sysUtil.getActor("transporttrolley") != null#]
		println("sonar | start with appl: $Appl")
	}Transition t0 whenMsg sonaractivate -> work
				 //whenMsg sonardeactivate -> end
	
	State work{
		//TODO: eventualmente modificare con onMsg all'interno dello stato
		[#var DLIMIT = payloadArg(0).toInt()#]
		updateResource[# "Sonar waiting"#]
	}Transition t0 whenEvent sonardata -> handlesonardata
	              whenEvent obstacle  -> handleobstacle
	              
	State handlesonardata{
		onMsg(sonardata : distance(D)){
			[#var D = payloadArg(0).toInt()#]
			println("$name distance ${payloadArg(0)}") color magenta
			if [#D>DLIMIT#]{
				emit resume: resume(_)
				println("RESUMING TransportTrolley")
			}
		}
	}Goto work
	
	State handleobstacle{
		onMsg( obstacle : obstacle(D)){			
			[#var D = payloadArg(0).toInt()#]
			println("$name handleobstacle ALARM ${payloadArg(0)}") color magenta
			// Alarm requirements
			if [#D <= DLIMIT#]{
				emit alarm : alarm(obstacle)
			    println("STOP TransportTrolley")	
			}		
		}
		
	}
	Goto end if [# Appl == true #]  else work  
	
	State end{
		println("$name BYE")
	}
}



QActor ledqakactor context ctxprototipo1 {

  State s0 initial{
		println("${name} STARTS")
	}
	Transition t0 whenMsg ledCmd -> doCmd

	State doCmd{ //da codificare i comandi del raspberry sprint4 
		//printCurrentMessage
		onMsg( ledCmd : ledCmd(V) ){
			[# var Cmd = payloadArg(0) #]
			if [# Cmd=="on" #]{
				//[# CommUtils.outyellow( "${name} - on") #]
				println("${name} - on") color magenta
			} if [# Cmd=="off" #]{
				//[# CommUtils.outyellow( "${name} - off")#]
				println("${name} - off") color magenta
			}else{
				//[# CommUtils.outyellow( "${name} - off")#]
				println("${name} - blink") color magenta
			}
		}
	}
	Transition t0 whenMsg ledCmd -> doCmd
}

QActor controller23 context ctxprototipo1{ //ctxpc{
[# val DLIMIT = 30 #] //valore casuale
	State s0 initial{
		println("${name} STARTS - Activates the sonar")
		forward sonar23 -m sonaractivate : info(DLIMIT) //TODO controllare se ci va messi
	}
	Transition t0 whenEvent sonardata -> doBusinessWork
				whenEvent robotmoving -> doBusinessWork

	State doBusinessWork{
		//printCurrentMessage
		onMsg( sonardata : distance(D)){
			[# var D = payloadArg(0).toInt() #]
			//Interact with the Led
			if [# D <= DLIMIT #]{
 				//println("${name} - Turn the Led on")
				forward ledqakactor -m ledCmd : ledCmd(on)
			}else{
 				//println("${name} - Turn the Led off")
				forward ledqakactor -m ledCmd : ledCmd(off)
			}
		}
		onMsg( robotmoving : robotmoving(_)){
			forward ledqakactor -m ledCmd : ledCmd(blink)
		}
	}
	Transition t0 whenEvent sonardata -> doBusinessWork

}



