<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<!--
<script type="text/javascript" src="../css/issStyle.js"></script>
-->
<link rel="stylesheet" type="text/css" href="resources/css/sprint0.css">

<head>

    <title>Sprint4</title></head>

<body>
<!--
<div id="top">
    <h1><b>PROGETTO DI INGEGNERIA DEI SISTEMI SOFTWARE</b> - SPRINT 0 <font size="5"></font></h1>
    <h3>Gruppo di lavoro: Focardi, Galeone, Porrazzo <font size="3"></font></h3>
</div>
-->
<div class="body">
    <h2>Introduction</h2>
    <div class="remark"> Progetto finale di ISS, finalizzato allo sviluppo software di un magazzino refrigerato, nel
        quale
        vi &egrave; un robot che ha il compito di Transportare del cibo da un punto di partenza - chiamato INDOOR - alla
        cella
        frigorifera.
    </div>
    <a href="https://htmlpreview.github.io/?https://github.com/LEOB3TA/ColdStorageService-Project/blob/main/Sprint0Reviewed/userDocs/sprint0Reviewed.html">Sprint0 </a><br>
    <a href="https://htmlpreview.github.io/?https://github.com/LEOB3TA/ColdStorageService-Project/blob/main/Sprint1/userDocs/sprint1.html">Sprint1 </a><br>
    <a href="https://htmlpreview.github.io/?https://github.com/LEOB3TA/ColdStorageService-Project/blob/main/Sprint2Reviewed/userDocs/sprint2.html">Sprint2 </a><br>
    <a href="https://htmlpreview.github.io/?https://github.com/LEOB3TA/ColdStorageService-Project/blob/main/Sprint3/userDocs/sprint3.html">Sprint3 </a>

    <h2>Requirements</h2>
    <div class="remark">
        <a href="https://htmlpreview.github.io/?https://github.com/anatali/issLab23/blob/main/iss23Material/html/TemaFinale23.html">Tema
            Finale </a>
    </div>

    <h3>Goal</h3>
    <div class="remark">
        In questo sprint ci occuperemo del
        <kc>deploy</kc>
        sul
        <kc>RaspberryPi</kc>
        e della distribuzione del software in modo da creare un'
        <kc>architettura distribuita</kc>
        . <br>
        Il fine di questo sprint &egrave; anche quello di riuscire a far funzionare il <b>Sonar</b>, il <b>Led</b> e il
        <b>Basicrobot</b> all'interno del
        <kc>RaspberryPi</kc>
        .<br>
        Quindi alla fine di questo sprint avremmo la seguente architettura:
        <ul>
            <li><b>RaspberryPi</b>, con all'interno
                <kc>Sonar</kc>
                ,
                <kc>Led</kc>
                e
                <kc>Basicrobot</kc>
            </li>
            <li>Un dispositivo per la
                <kc>ServiceAccessGUI</kc>
            </li>
            <li>Un dispostivo che contenga:
                <kc>ColdStorageService</kc>
                ,
                <kc>ServiceStatusGUI</kc>
                ,
                <kc>TransportTrolley</kc>
            </li>
        </ul>
    </div>

    <!--    </div>-->
    <!--    <h3>Work Plan</h3>-->
    <!--    <div class="remark" id=wp>-->
    <!--        <ul>-->
    <!--            <li></li>-->
    <!--        </ul>-->
    <!--    </div>-->

    <h2>Problem analysis</h2>
    Per ulteriori informazioni riguardanti il software precedentemente implementato fare riferimento fare riferimento ai
    precedenti Sprint.<br>
    <div class="remark">
        <h3>RaspberryPi</h3>
        <h3>Led</h3>
        Dall'analisi dei requisiti si evince che il
        <kc>Led</kc> &egrave; un componente fisico, connesso ad un
        RaspberryPi, che deve fornire indicazioni sullo stato del
        <kc>TransportTrolley</kc>
        .
        <h4>Obiettivo</h4>
        Gestire il <b>Led</b> in modo che rispetti i requisiti imposti dal cliente in particolare deve:
        <ol>
            <li>Essere <b>Spento</b> quando il TransportTrolley &egrave; in <b>HOME</b></li>
            <li><b>Lampeggiare</b> quando il TransportTrolley &egrave; <b>in movimento</b></li>
            <li>Essere <b>Acceso</b> quando il TransportTrolley &egrave; <b>fermo</b></li>
        </ol>
        <h4>Problemi</h4>
        Per un'analisi preliminare fare riferimento allo <a
            href="https://htmlpreview.github.io/?https://github.com/LEOB3TA/ColdStorageService-Project/blob/main/Sprint2Reviewed/userDocs/sprint2.html">Sprint2 </a>.<br>
        <br>
        <b>Problemi attuali:</b>
        <ol>
            <li>Come interagire con il <kc>Led fisico</kc></li>
            <li>Come riutilizzare la precedente implementazione del
                <kc>Led</kc>
            </li>
        </ol>
        <h4>Possibili soluzioni</h4>
        <ol>
            <li>Il <b>Led</b> &egrave; collegato al
                <kc>RaspberryPi</kc>
                attraverso i pin
                <kc>GPio</kc>
                ; per farlo funzionare &egrave; necessario attivare i suddetti pin. Per farlo sarebbe possibile:
                <ul>
                    <li>Modificare i file di sistema attraverso a riga i comando, ad esempio <b>echo 1 >
                        /sys/class/gpio/gpio25/value</b> ma ci&ograve; risulterebbe
                        <kc>scomodo</kc>
                        e molto
                        <kc>complicato</kc>
                        per la scrittura del codice
                    </li>
                    <li>Utilizzare delle librerie dei linguaggi di programmazione, ad esempio:
                        <kc>WiringPi</kc>
                        (per <i>C</i> e <i>Python</i>) oppure
                        <kc>pi4j</kc>
                        (per <i>Java</i> e <i>Kotlin</i>)
                    </li>
                </ul>
            </li>
            <li>Per riutilizzare i componenti gi&agrave; implementati sarebbe possibile:
                <ul>
                    <li>
                        <kc>Creare un programma</kc>
                        (in C o Python) che agisce come server e risponde ai comandi inviati dall'attore gi&agrave;
                        implementato. In questo contesto, l'attore dovrebbe essere modificato in modo che <i>rediriga
                        l'output</i> all'interno del programma implementato.
                        <table style="width:100%" border="1">
                            <tr>
                                <td style="width:40%" align="center"><i>PROS</i>
                                </td>
                                <td style="width:40%" align="center"><i>CONS</i>
                                </td>
                            </tr>
                            <tr>
                                <td>
                                    <kc>Separazione</kc>
                                    della logica di controllo dalla logica applicativa
                                </td>
                                <td>Necessit&agrave; di fare il
                                    <kc>deploy di un ulteriore file</kc>
                                </td>
                            </tr>
                            <tr>
                                <td>
                                    <kc>Facilit&agrave;</kc>
                                    di configurazione tra led reale e led simulato
                                </td>
                                <td>
                                    <kc>Frammentazione</kc>
                                    del codice su pi&ugrave; componenti
                                </td>
                            </tr>
                        </table>
                    </li>
                    <li>Utilizzare la libreria <i>pi4j</i> e
                        <kc>cablare il codice di accensione del led</kc>
                        all'interno dell'attore gi&agrave; implementato
                        <table style="width:100%" border="1">
                            <tr>
                                <td style="width:40%" align="center"><i>PROS</i>
                                </td>
                                <td style="width:40%" align="center"><i>CONS</i>
                                </td>
                            </tr>
                            <tr>
                                <td>
                                    <kc>Riutilizzo</kc>
                                    dello stesso codice
                                </td>
                                <td>
                                    <kc>Peggiore</kc>
                                    manutenzione del codice
                                </td>
                            </tr>
                            <tr>
                                <td>
                                    <kc>Facilit&agrave;</kc>
                                    di deploy
                                </td>
                                <td>
                                    <kc>Difficile</kc>
                                    cambiamento tra led reale e led simulato
                                </td>
                            </tr>
                        </table>
                    <li>Creare un
                        <kc>oggetto</kc>
                        <i>Kotlin</i>, utilizzando la libreria <i>pi4j</i> che risponda ai comandi inviati dall'attore
                    </li>
                    <table style="width:100%" border="1">
                        <tr>
                            <td style="width:40%" align="center"><i>PROS</i>
                            </td>
                            <td style="width:40%" align="center"><i>CONS</i>
                            </td>
                        </tr>
                        <tr>
                            <td>
                                <kc>Facilit&agrave;</kc>
                                di configurazione tra led reale e led simulato
                            </td>
                            <td>
                                <kc>Necessit&agrave;</kc>
                                di manutenere pi&ugrave; di un file
                            </td>
                        </tr>
                        <tr>
                            <td>
                                <kc>Integrit&agrave;</kc>
                                del linguaggio usato
                            </td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>
                                <kc>Facilit&agrave;</kc>
                                di deploy
                            </td>
                            <td></td>
                        </tr>
                    </table>
                </ul>
                Analizzando i pro e i contro &egrave; stato deciso di utiilizzare la <b>terza opzione</b></li>
        </ol>
        <h3>Sonar</h3>
        Dall'analisi dei requisiti si evince che il
        <kc>Sonar</kc> &egrave; un componente fisico, connesso ad un
        RaspberryPi, il quale genera delle informazioni relative alla distanza da un ostacolo. Per tale motivo
        si pu&ograve; modellare il sonar come un processo che una volta attivato genera informazioni sugli ostacoli.

        <h4>Obiettivo</h4>
        Avere un componente che fornisca la <b>distanza</b> del robot da un ostacolo
        <h4>Problemi</h4>
        Per un'analisi preliminare fare riferimento allo <a
            href="https://htmlpreview.github.io/?https://github.com/LEOB3TA/ColdStorageService-Project/blob/main/Sprint2Reviewed/userDocs/sprint2.html">Sprint2</a>.
        <br><br>
        <b>Problemi attuali:</b>
        <ul>
            <li>Come interagire con il <kc>Sonar fisico</kc></li>
            <li>Come riutilizzare la precedente implementazione del
                <kc>Sonar</kc>
            </li>
        </ul>

        <h4>Possibili soluzioni</h4>
        Il cliente ci ha precedentemente fornito il software per il <b>Sonar</b> (<a
            href="https://github.com/anatali/issLab23/tree/main/unibo.sonarqak23">unibo.sonarqak23</a>) che fornisce un
        implementazione sia per il sonar simulato sia per il sonar fisico.<br>
        Il software &egrave; stato precedentemente <b>modificato</b> nello <a
            href="https://htmlpreview.github.io/?https://github.com/LEOB3TA/ColdStorageService-Project/blob/main/Sprint2Reviewed/userDocs/sprint2.html">Sprint2</a>, quindi &egrave; necessario cambiare solamente l'implmentazione del sonar utilizzando la classe <i>sonarHCSR04Support23</i>.<br>
        Per i dettagli delle interazioni del sonar fisico con l'attore <i>sonar23</i> consultare lo <a
            href="https://htmlpreview.github.io/?https://github.com/LEOB3TA/ColdStorageService-Project/blob/main/Sprint2Reviewed/userDocs/sprint2.html">Sprint2</a>.
        <h3>Basicrobot</h3>
        Il basicrobot &egrave; un componente precedentemente fornito che si occupa di tutto il movimento del transporttrolley, per i dettagli delle interazioni <b>basicrobot-transporttrolley</b> consultare lo <a href="https://htmlpreview.github.io/?https://github.com/LEOB3TA/ColdStorageService-Project/blob/main/Sprint1/userDocs/sprint1.html">Sprint1</a><br>
        <h4>Obiettivo</h4>
        Cambiare l'implementazione del <i>basicrobot</i> da robot virtuale a robot fisico
        <h4>Problemi</h4>
        <ol>
            <li>Creare l'<kc>architettura hardware</kc> su cui fare il deploy del basicrobot</li>
            <li>Conversione dei comandi al <i>wenv</i> in comandi per il robot fisico</li>
            <li>Come fare il <kc>deploy</kc></li>
        </ol>
        <h4>Possibili soluzioni</h4>
        <ol>
            <li>Per la creazione dell'architettura &egrave; necessario analizzare la documentazione fornita insieme al <i>basicrobot</i> che specifica quali componenti avere e come collegarli al <b>RaspberryPi</b> per creare un robot denominato <kc>realnano</kc>.<br> Tale robot contiene anche il supporto hardware per il <i>sonar</i> e per il <i>led</i></li>
            <li>Analizzando la documentazione fornita insieme al <i>basicrobot</i> si evince che il supporto per i movimenti pu&ograve; essere implementato in 3 modi: <b>virtual</b>,<b>realnano</b>,<b>realmbot</b>.<br>
            L'implementazione che interessa a noi &egrave; <kc>realnano</kc>, quindi &egrave; necessario modificare il file di configurazione (<i>basicrobotconfig.json</i>) nel seguente modo:
            <pre>
{"type":"realnano", "port":"8090", "iprobot":"[robotip]", "commtrace": "false"}
            </pre></li>
            <li>Dopo il colloquio con il committente, ci &egrave; stato consegnato il codice sorgente, suggerendoci l'utilizzo del target <kc>Gradle</kc> <i>distZip</i>. Il file ZIP generato deve successivamente essere estratto nell'ambiente <kc>RaspberryPi</kc>, e l'esecuzione del programma deve avvenire mediante il file contenuto nella cartella <i>bin</i>. In aggiunta, &egrave; richiesto il trasferimento di tutti i file di configurazione indispensabili.</li>
        </ol>
        <h3>Modifica dei contesti</h3>
        Tutte le componenti presenti all'interno del <kc>RaspberryPi</kc> devono eseguire in un contesto indipendente dagli altri componenti del sistema.
        <h4>Problemi</h4>
        <ol>
            <li>Come <kc>modificare</kc> il software preesistente in modo che esegua su un <b>RaspberryPi</b>, senza influenzare il comportamento gi&agrave; sperimentato</li>
        </ol>
        <h4>Possibili soluzioni</h4>
        <ol>
            <li>Avendo utilizzato il linguaggio <b>Qak</b> per la precedente implementazione &egrave; sufficiente<ul>
                <li>Creare un progetto <i>Gradle</i> a s&eacute; stante</li>
                <li>Specificare il nuovo contesto su cui eseguir&agrave; il software (<i>ctxrasp</i>) </li>
                <li>Fare il deploy sul computer attraverso un jar</li>
            </ul></li>
        </ol>
        <b>--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------</b>
        <h3>ServiceAccessGUI</h3>
        Dall'analisi dei requisiti si evince che la <kc>ServiceAccessGUI</kc> deve essere eseguita su una computer <b>esterno</b> rispetto all'intero sistema.
        <h4>Problemi</h4>
        <ol>
            <li>Come <kc>modificare</kc> la GUI preesistente in modo che esegua su un computer esterno al sistema, senza influenzare il comportamento gi&agrave; sperimentato</li>
        </ol>
        <h4>Possibili soluzioni</h4>
        <ol>
            <li>Avendo usato <kc>Flutter</kc> che si connette al server <kc>Spring</kc> (considerando che il server eseguir&agrave; sullo stesso computer del CSS) occorre:<ul>
                <li>Modificare l'<b>indirizzo</b> del server a cui si connette la GUI</li>
                <li>Fare la <b>build</b> della GUI</li>
                <li>Fare eseguire la GUI sul dispositivo</li>
            </ul></li>
        </ol>
        <h3>ColdStorageService,TransportTrolley</h3>
        Dall'analisi dei requisiti si evince che questi componenti devon essere eseguiti su un computer a se stante.
        <h4>Problemi</h4>
        <ol>
            <li>Come <kc>modificare</kc> il software preesistente in modo che esegua su un computer esterno al sistema, senza influenzare il comportamento gi&agrave; sperimentato</li>
        </ol>
        <h4>Possibili soluzioni</h4>
        <ol>
            <li>Avendo utilizzato il linguaggio <b>Qak</b> per la precedente implementazione &egrave; sufficiente<ul>
                <li>Creare un progetto <i>Gradle</i> a se stante</li>
                <li>Specificare i nuovi contesti, in particolare: un nuovo contesto per le tre componenti (<i>ctxstorageservice</i>), un contesto per il <b>basicrobot</b> (<i>ctxbasicrobot</i>) e uno per il <b>Raspberry</b> (<i>ctxrasp</i>) con la definizione degli attori <i>external</i></li>
                <li>Fare il deploy sul computer attraverso un container <b>Docker</b>, rendendo pi&ugrave; compatibile il nostro software e rendendo pi&ugrave; facile il deploy nei vari dispositivi.</li>
            </ul></li>
        </ol>
        <h3>ServiceStatusGUI</h3>
        Questo componente pu&ograve; essere eseguito sia nello stesso contesto del <b>CSS</b> che in un contesto esterno
        <h4>Problemi</h4>
        <ol>
            <li>Decidere dove far eseguire la GUI</li>
            <li>Come <kc>modificare</kc> il software preesistente, senza influenzare il comportamento gi&agrave; sperimentato</li>
        </ol>
        <h4>Possibili soluzioni</h4>
        <ol>
          <li>La <kc>GUI</kc> ha possibilit&agrave;:
        <ul>
            <li>Eseguire nello stesso contesto del <b>CSS</b>
            <table style="width:100%" border="1">
                <tr>
                    <td style="width:40%" align="center"><i>PROS</i>
                    </td>
                    <td style="width:40%" align="center"><i>CONS</i>
                    </td>
                </tr>
                <tr>
                    <td>
                        Pi&ugrave; <kc>Economico</kc>
                        per via del costo dell' hardware
                    </td>
                    <td><kc>Maggior carico</kc> su un singolo nodo
                    </td>
                </tr>
                <tr>
                    <td>
                        <kc>Deploy</kc>
                       pi&ugrave; semplice
                    </td>
                    <td>
                        <kc>Minore tolleranza ai guasti</kc>
                    </td>
                </tr>
            </table>
            </li>
            <br>
            <li>Esguire in un contesto diverso
                <table style="width:100%" border="1">
                    <tr>
                        <td style="width:40%" align="center"><i>PROS</i>
                        </td>
                        <td style="width:40%" align="center"><i>CONS</i>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <kc>Separazione</kc>
                            della logica di controllo dalla logica applicativa
                        </td>
                        <td>Necessit&agrave; di fare il
                            <kc>deploy su pi&ugrave; dispositivi</kc>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <kc>Maggiore tolleranza ai guasti</kc>
                        </td>
                        <td>
                            <kc>Maggiore costo</kc>
                            per via del costo dell' hardware
                        </td>
                    </tr>
                </table>
            </li>
            Abbiamo scelto si utilizzare il primo approccio per una questione di comodit&agrave; nel deploy; in futuro se necessario sar&agrave; possibile spostare la GUI su un contesto diverso in modo semplice.
            <br>
            <br>
        </ul>
          </li>
            <li>Avendo usato <kc>Flutter</kc> che si connette al server <kc>Spring</kc> (considerando che il server eseguir&agrave; sullo stesso computer del CSS) occorre:<ul>
                <li>Modificare l'<b>indirizzo</b> del server a cui si connette la GUI</li>
                <li>Fare la <b>build</b> della GUI</li>
                <li>Fare eseguire la GUI sul dispositivo</li>
            </ul></li>
        </ol>
        <h3>ServerSpring</h3>
        Dall'analisi dei requisiti si evince che questo componente deve eseguire sullo stesso contesto del <b>CSS</b>.
        <h4>Problemi</h4>
        <ol>
            <li>Come <kc>modificare</kc> il software preesistente, senza influenzare il comportamento gi&agrave; sperimentato</li>
        </ol>
        <h4>Possibili soluzioni</h4>
        <ol>
            <li>Per garantire la compatibilit&agrave; del software su diversi dispositivi si &egrave; pensato di utilizzare un container <b>Docker</b>, rendendo pi&ugrave; facile il deploy nei vari dispositivi.</li>
        </ol>
        <b>--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------</b>
        <h3>Revisione dei precedenti sprint</h3>
        <h4>Problemi</h4>
        <ol>
            <li>La <i>Service Access GUI</i> non fornisce un pulsante per <kc>ripetere</kc> la procedura di accesso, inoltre non possiede un meccanismo per <kc>notificare</kc> l'inserimento di un biglietto scaduto/errato.</li>
            <li>Il <i>CSS</i> non possiede un meccanismo automatico per <kc>gestire la scadenza dei ticket</kc>, in particolare la scadenza viene controllata solo al momento dell'inserimento del ticket scaduto, di conseguenza <kc>il peso presente all'interno della struttura non viene aggiornato in tempo reale</kc>.</li>
            <li>La classe <i>Ticket</i> non possiede il valore del peso, di conseguenza <kc>l'associazione peso-ticket</kc> viene fatta direttamente dal <i>CSS</i> <kc>senza tenere traccia del</kc> <b>TICKETID</b>, di conseguenza ci potrebbero essere problemi nel caso di pi&ugrave; ticket scaduti.</li>
            <br>
            Per rendere pi&ugrave; comprensibile le due problematiche viene riportato un esempio:<br><br>
            Ipotizziamo che <b>due</b> autisti facciano la richiesta di accesso uno dopo l'altro e il <b>peso massimo</b> immagazinabile sia di <b>100 Kg</b>; le fasi che si affronterebbero sono le seguenti:
                <br><br>
            <ol>
                <li>L'autista <b>A</b> effettua una richiesta <kc>store food</kc> di <b>20 Kg</b> che viene <kc>accettata</kc> con il TICKETID pari a <b>1</b>. (<i>Stato: 20Kg/100Kg, ultima richiesta di peso: 20Kg</i>)</li>
                <li>L'autista <b>B</b> effettua una richiesta <kc>store food</kc> di <b>10 Kg</b> che viene <kc>accettata</kc> con il TICKETID pari a <b>2</b>. (<i>Stato: 30Kg/100Kg, ultima richiesta di peso: 10Kg</i>)</li>
                <li><kc>Entrambi</kc> gli autisti fanno <kc>scadere</kc> il loro ticket</li>
                <li>L'autista <b>A</b> presenta il proprio ticket con TICKETID pari a <b>1</b> con un peso associato di <b>20 Kg</b>.</li>
                <li>Viene notificato l'invio di un ticket scaduto all'autista <b>A</b> e viene aggiornato il peso sottraendo il valore dell'ultima richiesta di peso che per&oacute; &eacute; di <b>10 Kg</b>. (<i>Stato: 20Kg/100Kg, ultima richiesta di peso: 10Kg</i>)</li>
                <li>L'autista <b>B</b> presenta il proprio ticket con TICKETID pari a <b>2</b> con un peso associato di <b>10 Kg</b>.</li>
                <li>Viene notificato l'invio di un ticket scaduto all'autista <b>B</b> e viene aggiornato il peso sottraendo il valore dell'ultima richiesta di peso che &eacute; di <b>10 Kg</b>. (<i>Stato: 10Kg/100Kg, ultima richiesta di peso: 10Kg</i>)</li>
            </ol></li>
            Considerando che il peso finale dovrebbe essere 0 Kg &egrave; evidente che questo &egrave; un problema da risolvere
        </ol>
        <h4>Possibili soluzioni</h4>
        <ol>
            <li><kc>Modificare</kc> il front-end in modo da <kc>aggiungere</kc> i pulsanti richiesti e in modo da <kc>fornire</kc> dei banner per la notifica dei ticket.</li>
            <li><kc>Modificare</kc> la classe <i>Ticket</i> in modo che mantenga traccia del peso associato al ticket.</li>
            <li><kc>Creare</kc> un meccanismo di aggiornamento automatico del peso, attraverso una <i>Coroutine Kotlin</i> <kc>modificando</kc> l'oggetto Kotlin <i>ColdStorageService</i>.</li>
        </ol>
    </div>
    <h2>Architettura Logica</h2>
    <br>
   <!-- Modello prototipo: <a style="font-size: larger"
                          href="https://github.com/LEOB3TA/ColdStorageService-Project/blob/main/Sprint2/unibo.prototipo1/src/prototipo1.qak"
                          target="_blank">protipo2.qak</a>
    <br>-->
    <img height="100%" width="100%" src="resources/images/sprint4arch.png" alt="architettura logica"> <br>
</div>


<h2>Project</h2>
<div class="remark">
    Per prima cosa &egrave; stato necessario analizzare il file <a href="https://github.com/LEOB3TA/ColdStorageService-Project/blob/main/Sprint3/unibo.prototipo3/src/prototipo3.qak">prototipo3.qak</a> dividendo gli attori gi&agrave; creati nei contesti finali; per farlo sono stati creati i seguenti file qak:
    <ul>
        <li><a href="https://github.com/LEOB3TA/ColdStorageService-Project/blob/main/Sprint4/unibo.ctxrasp/src/ctxrasp.qak">ctxrasp.qak</a></li>
        <li><a href="https://github.com/LEOB3TA/ColdStorageService-Project/blob/main/Sprint4/coldStorageService/unibo.ctxstorageservice/src/ctxstorageservice.qak">ctxstorageservice.qak</a></li>
    </ul>
    Tutte le ulteriori modifiche effettuate nei vari contesti e nei file associati verranno dettagliate in seguito.
    <h3>RaspberryPi</h3>
    <h3>Led</h3>
    Come indicato nell'<b>Analisi del problema</b> &egrave; stato scelto di utilizzare la libreria <kc>pi4j</kc>.<br>
    Di conseguenza &egrave; stato necessario inserire la dipendenza all'interno del file Gradle.<br>
    A questo punto per garantire <b>versatilit&agrave;</b> del software abbiamo pensato di creare un <kc>oggetto Kotlin</kc> che funga da supporto per il led e cambi il proprio comportamento secondo un file di configurazione, in particolare, all'interno del file <a href="https://github.com/LEOB3TA/ColdStorageService-Project/blob/main/Sprint4/unibo.ctxrasp/ledConfig.json">ledConfig.json</a> &egrave; possibile specificare due tipologie di led:
    <ul>
        <li><b>simulated</b>: in questo caso il supporto stamper&agrave; a video l'output del led</li>
        <li><b>real</b>: in questo caso il supporto attraverso la libreria <kc>pi4j</kc> utilizzer&agrave; i pin <b>GPio</b> per manipolare il led</li>
    </ul>
    All'interno del file <a href="https://github.com/LEOB3TA/ColdStorageService-Project/blob/main/Sprint4/unibo.ctxrasp/resources/ledSupport.kt">ledSupport.kt</a> viene specificata la logica del led; in particolare attraverso la funzione <b>create()</b> viene scelta la tipologia del led e nel caso sia <kc>real</kc> viene creato istanziato il supporto fisico attraveso la <kc>GPiofactory</kc> della libreria <kc>pi4j</kc>.
    Sono disponibili tre funzioni per comandare il led: <b>on()</b>,<b>off()</b>,<b>blink()</b>: ognuna di queste avr&agrave; un comportamento diverso a seconda del tipo di led specificato nel file di configurazione; per completezza viene riportato un esempio: <br>
    <pre>
fun blink(){
    when(ledType){
        "simulated" -> CommUtils.outmagenta("LED BLINKS")
        "real" -> gpioPin.blink(500)
    }
}
    </pre>
    <br>
    A seguito di queste modifiche &egrave; stato necessario modificare il file <b>Qak</b> in modo da sfruttare il nuovo supporto, di conseguenza &egrave; bastato sostituire le print presenti nel vecchio file <b>Qak</b> con le chiamate al supporto per il led.
    <h3>Sonar</h3>
    Considerando il software precedentemente fornito &egrave; bastato modificare leggermente il file <b>ctxrap.qak</b> utilizzando come <i>CodedQActor</i> <kc>rx.sonarHCSR04Support23</kc>.
    <pre>
CodedQActor sonar  context ctxrasp className "rx.sonarHCSR04Support23"
    </pre>
    <b>--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------</b>
    <h3>ServiceAccessGUI</h3>
    Per modificare l'indirizzo del server &egrave; stato necessario modificare il file <a href="https://github.com/LEOB3TA/ColdStorageService-Project/blob/8ca7cfc071998b7c769ead0fddfa3dd8d0f7bcb0/Sprint4/serviceaccessgui/lib/service/ws_service.dart">ws_service.dart</a>.
    <pre>
class WsService {
  static const socketUrl = 'ws://'server-ip':11804/ws-message'; // if in another pc
}
    </pre>
    </ol>
    <h3>ColdStorageService,TransportTrolley</h3>
    Dopo aver creato il file <kc>Qak</kc> a se stante, &egrave; stato necessario creare un jar tramite il target Gradle <i>shadowJar</i>, per poi inserirlo all'interno di un container <kc>Docker</kc> per garantire il massimo della compatibilit&agrave;.<br>
    <h3>ServerSpring</h3>
    Dopo aver creato il jar tramite il target Gradle <i>bootJar</i>, &egrave;  stato inserito all'interno di un container <kc>Docker</kc> per garantire il massimo della compatibilit&agrave;.<br>
    <h3>Problemi con Docker</h3>
    Purtroppo durante il progetto l'idea di eseguire il deploy attraverso dei container si &egrave; rivelata <b>problematica</b> per via di un <b>errore con gli observer CoAP</b>.<br>
    In particolare durante l'esecuzione dell'immagine Docker ci siamo accorti che tutti gli observer implementati tramite il linguaggio <i>Qak</i> non funzionavano stampando l'errore <i>OBSERVING FAILED</i>, in particolare gli attori <kc>stateobservercontroller</kc> e  <kc>guicontroller</kc> osservano il <kc>transporttrolley</kc>, di conseguenza <b>non funzionavano</b> <kc>parte della ServiceStatusGUI e il led del robot</kc>.
    <br>
    <br> A seguito di una settimana di studio e di tentativi, il team ha deciso all'unanimit&agrave; di <b>abbandonare</b> il deploy attraverso i container e di <b>procedere con il metodo utilizzato nei precedenti sprint</b>.
    <br>
    <b>--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------</b>
    <h3>Revisione dei precedenti sprint</h3>
    <h4>Modifica del front-end</h4>
    &Egrave; stato modificato il file <a href="https://github.com/LEOB3TA/issProject2023/blob/bd358d4148ba47dc2e95d706b6e28a00f13b75eb/Sprint4/serviceaccessgui/lib/widgets/stepper_widget.dart">stepper_widget.dart</a> della <i>service access GUI</i> in modo da aggiungere i nuovi <kc>pulsanti</kc> e delle <kc>snackbar</kc> di errore.
    <h4>Modifica della classe Ticket</h4>
    Il file <a href="https://github.com/LEOB3TA/issProject2023/blob/ea58444b2c1b5d0120bd7336e332e8991650c848/Sprint4/coldStorageService/unibo.ctxstorageservice/resources/model/Ticket.kt">Ticket.kt</a> &egrave; stato modificato aggiungendo il <kc>valore weight di tipo Double</kc>, inoltre &egrave; stato <kc>modificato</kc> il metodo <b>isExpired()</b> e <kc>aggiunto</kc> un nuovo metodo <b>controlExpired()</b>, in questo modo <b>isExpired()</b> diventa un semplice <i>getter</i> e <b>ControlExpired()</b> serve a controllare l'effettiva scadenza del ticket.
    <pre>
...
private val weight : Double
...
fun controlExpired(): Boolean{
        isExpired = LocalDateTime.now() > ticketTime
        return isExpired
}
fun isExpired(): Boolean {
    return isExpired
}
    </pre>
La motivazione della modifica dei due metodi verr&agrave; descritta successivamente.
    <h4>Modifica dell'oggetto ColdStorageService</h4>
Il file <a href="https://github.com/LEOB3TA/issProject2023/blob/dafbbd0ccc81bebbd9f728c5ef0342ac79c60272/Sprint4/coldStorageService/unibo.ctxstorageservice/resources/ColdStorageService.kt">ColdStorageService.kt</a> &egrave; stato modificato inserendo un nuovo metodo <b>inizializeControl()</b> che una volta chiamato <kc>inizializza una coroutine</kc> che controller&agrave; periodicamente (ogni 10 secondi) quali dei ticket presenti all'interno dell'array <b>ticketList</b> sono scaduti e in caso affermativo sottrarr&agrave; il peso del ticket dal peso complessivo all'interno del sistema.
    <pre>
fun inizializeControl(){
        runBlocking {
            GlobalScope.launch {
                while (true) {
                    delay(10000L)
                    getInstance().ticketList.forEach {
                        if(!it.isExpired() && it.controlExpired()){
                            println(getInstance().currentWeightStorage)
                            getInstance().currentWeightStorage -= it.getWeight()
                            println(getInstance().currentWeightStorage)
                        }
                    }
                }
            }
        }
}
    </pre>
    &Egrave; necessario notare come il ticket scaduto <kc>non venga rimosso</kc> dal sistema, in questo modo non &egrave; necessario tenere traccia di tutti i ticket scaduti attraverso un altro array, il controllo della scadenza, per l'autista, viene fatto all'inserimento del ticket attraverso la funzione <b>isExpired()</b> e solamente in seguito il ticket <kc>viene rimosso</kc> dal sistema. In questo modo si riesce a garantire l' <kc>aggiornamento in tempo reale</kc> del peso all'interno del sistema.<br>
    Il doppio controllo sull'if &egrave; necessario per far fronte ai ticket scaduti presenti nel sistema, infatti un ticket che non &egrave; ancora stato controllato avr&agrave; <b>isExpired()=false</b> invece <b>controlExpired()=true</b>.
    <br>
    <br>
    A seguito di queste modifiche &egrave; stato necessario modificare il file <a href="https://github.com/LEOB3TA/issProject2023/blob/dafbbd0ccc81bebbd9f728c5ef0342ac79c60272/Sprint4/coldStorageService/unibo.ctxstorageservice/src/ctxstorageservice.qak">ctxstorageservice.qak</a> in modo da supportarle.
</div>
<h2>Testing e avvio del sistema</h2>
<div class="remark">
    Al fine di testare il corretto funzionamento di tutti i componenti &egrave; necessario eseguire il software in modo distribuito, per farlo occorre:
    <ol>
        <li>Scaricare tutte le componenti nei dispositivi finali</li>
        <li>Avviare il <b>basicrobot</b> e gli <b>attori</b> all'interno del <kc>RaspberryPi</kc> grazie allo script di avvio <i>startRasp.sh</i></li>
        <li>Avviare il <b>ColdStorageService</b> e il <b>Server</b> attraverso il file <i>startPrototype-XXX.sh/bat</i> all'interno del <kc>ColdStorageServiceDevice</kc>(PC del manager)</li>
        <li>Avviare la <b>ServiceStatusGUI</b> attraverso il file <i>eseguibile</i> all'interno del <kc>ColdStorageServiceDevice</kc>(PC del manager)</li>
        <li>Avviare la <b>ServiceAccessGUI</b> attraverso il file <i>eseguibile</i> su uno o pi&ugrave; <kc>dispositivi esterni</kc>(PC degli autisti)</li>
    </ol>
    Per dimostrare il corretto funzionamento del sistema viene riportato un video dell'esecuzione.
    <br>
    <video controls autoplay>
        <source src="./resources/video/Graphic Designer_VS_Programmer.mp4" type="video/mp4">
        <source src="./resources/video/Graphic Designer_VS_Programmer.mp4" type="video/ogg">
        Your browser does not support the video tag.
    </video>
</div>

<!--
            <h2>Maintenance</h2>
            -->
<!-- USEFUL
<table style="width:100%" border="1">
<tr>
<td style="width:40%">
</td>
<td></td>
</tr>
</table>
-->

<div class="stud">
    By Students: <br/>
    <div class="studentCardRow">
        <div class="studentCard">
            <div class="studentName">Leonardo Focardi</div>
            <div class="studentEmail"><a
                    href="mailto:leonardo.focardi@studio.unibo.it">leonardo.focardi@studio.unibo.it</a>
            </div>
            <div class="studentImg"><img class="studentAvatar" src="./resources/boys/leo.jpg"></div>
        </div>
        <div class="studentCard">
            <div class="studentName">Christian Galeone</div>
            <div class="studentEmail"><a href="mailto:christian.galeone@studio.unibo.it">christian.galeone@studio.unibo.it</a>
            </div>
            <div class="studentImg"><img class="studentAvatar" src="./resources/boys/christian.jpg"></div>
        </div>
        <div class="studentCard">
            <div class="studentName">Gianmiriano Porrazzo</div>
            <div class="studentEmail"><a href="mailto:gianmiriano.porrazzo@studio.unibo.it">gianmiriano.porrazzo@studio.unibo.it</a>
            </div>
            <div class="studentImg"><img class="studentAvatar" src="./resources/boys/gian.jpg"></div>
        </div>
    </div>

    <div class="repo">
        GIT repo: <a href="https://github.com/LEOB3TA/ColdStorageService-Project">https://github.com/LEOB3TA/ColdStorageService-Project</a>
    </div>
</div>
</body>
</html>