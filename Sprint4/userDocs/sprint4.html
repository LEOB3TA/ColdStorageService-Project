<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<!--
<script type="text/javascript" src="../css/issStyle.js"></script>
-->
<link rel="stylesheet" type="text/css" href="resources/css/sprint0.css">

<head>

    <title>Sprint4</title></head>

<body>
<!--
<div id="top">
    <h1><b>PROGETTO DI INGEGNERIA DEI SISTEMI SOFTWARE</b> - SPRINT 0 <font size="5"></font></h1>
    <h3>Gruppo di lavoro: Focardi, Galeone, Porrazzo <font size="3"></font></h3>
</div>
-->
<div class="body">
    <h2>Introduction</h2>
    <div class="remark"> Progetto finale di ISS, finalizzato allo sviluppo software di un magazzino refrigerato, nel
        quale
        vi &egrave; un robot che ha il compito di Transportare del cibo da un punto di partenza - chiamato INDOOR - alla
        cella
        frigorifera.
    </div>
    <a href="https://htmlpreview.github.io/?https://github.com/LEOB3TA/ColdStorageService-Project/blob/main/Sprint0Reviewed/userDocs/sprint0Reviewed.html">Sprint0 </a><br>
    <a href="https://htmlpreview.github.io/?https://github.com/LEOB3TA/ColdStorageService-Project/blob/main/Sprint1/userDocs/sprint1.html">Sprint1 </a><br>
    <a href="https://htmlpreview.github.io/?https://github.com/LEOB3TA/ColdStorageService-Project/blob/main/Sprint2Reviewed/userDocs/sprint2.html">Sprint2 </a><br>
    <a href="https://htmlpreview.github.io/?https://github.com/LEOB3TA/ColdStorageService-Project/blob/main/Sprint3/userDocs/sprint3.html">Sprint3 </a>

    <h2>Requirements</h2>
    <div class="remark">
        <a href="https://htmlpreview.github.io/?https://github.com/anatali/issLab23/blob/main/iss23Material/html/TemaFinale23.html">Tema
            Finale </a>
    </div>

    <h3>Goal</h3>
    <div class="remark">
        In questo sprint ci occuperemo del
        <kc>deploy</kc>
        sul
        <kc>RaspberryPi</kc>
        e della distribuzione del software in modo da creare un'
        <kc>architettura distribuita</kc>
        . <br>
        Il fine di questo sprint &egrave; anche quello di riuscire a far funzionare il <b>Sonar</b>, il <b>Led</b> e il
        <b>Basicrobot</b> all'interno del
        <kc>RaspberryPi</kc>
        .<br>
        Quindi alla fine di questo sprint avremmo la seguente architettura:
        <ul>
            <li><b>RaspberryPi</b>, con all'interno
                <kc>Sonar</kc>
                ,
                <kc>Led</kc>
                e
                <kc>Basicrobot</kc>
            </li>
            <li>Un dispositivo per la
                <kc>ServiceAccessGUI</kc>
            </li>
            <li>Un dispostivo che contenga:
                <kc>ColdStorageService</kc>
                ,
                <kc>ServiceStatusGUI</kc>
                ,
                <kc>TransportTrolley</kc>
            </li>
        </ul>
    </div>

    <!--    </div>-->
    <!--    <h3>Work Plan</h3>-->
    <!--    <div class="remark" id=wp>-->
    <!--        <ul>-->
    <!--            <li></li>-->
    <!--        </ul>-->
    <!--    </div>-->

    <h2>Problem analysis</h2>
    Per ulteriori informazioni riguardanti il software precedentemente implementato fare riferimento fare riferimento ai
    precedenti Sprint.<br>
    <div class="remark">
        <h3>RaspberryPi</h3>
        <h3>Led</h3>
        Dall'analisi dei requisiti si evince che il
        <kc>Led</kc> &egrave; un componente fisico, connesso ad un
        RaspberryPi, che deve fornire indicazioni sullo stato del
        <kc>TransportTrolley</kc>
        .
        <h4>Obiettivo</h4>
        Gestire il <b>Led</b> in modo che rispetti i requisiti imposti dal cliente in particolare deve:
        <ol>
            <li>Essere <b>Spento</b> quando il TransportTrolley &egrave; in <b>HOME</b></li>
            <li><b>Lampeggiare</b> quando il TransportTrolley &egrave; <b>in movimento</b></li>
            <li>Essere <b>Acceso</b> quando il TransportTrolley &egrave; <b>fermo</b></li>
        </ol>
        <h4>Problemi</h4>
        Per un'analisi preliminare fare riferimento allo <a
            href="https://htmlpreview.github.io/?https://github.com/LEOB3TA/ColdStorageService-Project/blob/main/Sprint2Reviewed/userDocs/sprint2.html">Sprint2 </a>.<br>
        <br>
        <b>Problemi attuali:</b>
        <ol>
            <li>Come interagire con il <kc>Led fisico</kc></li>
            <li>Come riutilizzare la precedente implementazione del
                <kc>Led</kc>
            </li>
        </ol>
        <h4>Possibili soluzioni</h4>
        <ol>
            <li>Il <b>Led</b> &egrave; collegato al
                <kc>RaspberryPi</kc>
                attraverso i pin
                <kc>GPio</kc>
                ; per farlo funzionare &egrave; necessario attivare i suddetti pin. Per farlo sarebbe possibile:
                <ul>
                    <li>Modificare i file di sistema attraverso a riga i comando, ad esempio <b>echo 1 >
                        /sys/class/gpio/gpio25/value</b> ma ci&ograve; risulterebbe
                        <kc>scomodo</kc>
                        e molto
                        <kc>complicato</kc>
                        per la scrittura del codice
                    </li>
                    <li>Utilizzare delle librerie dei linguaggi di programmazione, ad esempio:
                        <kc>WiringPi</kc>
                        (per <i>C</i> e <i>Python</i>) oppure
                        <kc>pi4j</kc>
                        (per <i>Java</i> e <i>Kotlin</i>)
                    </li>
                </ul>
            </li>
            <li>Per riutilizzare i componenti gi&agrave; implementati sarebbe possibile:
                <ul>
                    <li>
                        <kc>Creare un programma</kc>
                        (in C o Python) che agisce come server e risponde ai comandi inviati dall'attore gi&agrave;
                        implementato. In questo contesto, l'attore dovrebbe essere modificato in modo che <i>rediriga
                        l'output</i> all'interno del programma implementato.
                        <table style="width:100%" border="1">
                            <tr>
                                <td style="width:40%" align="center"><i>PROS</i>
                                </td>
                                <td style="width:40%" align="center"><i>CONS</i>
                                </td>
                            </tr>
                            <tr>
                                <td>
                                    <kc>Separazione</kc>
                                    della logica di controllo dalla logica applicativa
                                </td>
                                <td>Necessit&agrave; di fare il
                                    <kc>deploy di un ulteriore file</kc>
                                </td>
                            </tr>
                            <tr>
                                <td>
                                    <kc>Facilit&agrave;</kc>
                                    di configurazione tra led reale e led simulato
                                </td>
                                <td>
                                    <kc>Frammentazione</kc>
                                    del codice su pi&ugrave; componenti
                                </td>
                            </tr>
                        </table>
                    </li>
                    <li>Utilizzare la libreria <i>pi4j</i> e
                        <kc>cablare il codice di accensione del led</kc>
                        all'interno dell'attore gi&agrave; implementato
                        <table style="width:100%" border="1">
                            <tr>
                                <td style="width:40%" align="center"><i>PROS</i>
                                </td>
                                <td style="width:40%" align="center"><i>CONS</i>
                                </td>
                            </tr>
                            <tr>
                                <td>
                                    <kc>Riutilizzo</kc>
                                    dello stesso codice
                                </td>
                                <td>
                                    <kc>Peggiore</kc>
                                    manutenzione del codice
                                </td>
                            </tr>
                            <tr>
                                <td>
                                    <kc>Facilit&agrave;</kc>
                                    di deploy
                                </td>
                                <td>
                                    <kc>Difficile</kc>
                                    cambiamento tra led reale e led simulato
                                </td>
                            </tr>
                        </table>
                    <li>Creare un
                        <kc>oggetto</kc>
                        <i>Kotlin</i>, utilizzando la libreria <i>pi4j</i> che risponda ai comandi inviati dall'attore
                    </li>
                    <table style="width:100%" border="1">
                        <tr>
                            <td style="width:40%" align="center"><i>PROS</i>
                            </td>
                            <td style="width:40%" align="center"><i>CONS</i>
                            </td>
                        </tr>
                        <tr>
                            <td>
                                <kc>Facilit&agrave;</kc>
                                di configurazione tra led reale e led simulato
                            </td>
                            <td>
                                <kc>Necessit&agrave;</kc>
                                di manutenere pi&ugrave; di un file
                            </td>
                        </tr>
                        <tr>
                            <td>
                                <kc>Integrit&agrave;</kc>
                                del linguaggio usato
                            </td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>
                                <kc>Facilit&agrave;</kc>
                                di deploy
                            </td>
                            <td></td>
                        </tr>
                    </table>
                </ul>
                Analizzando i pro e i contro &egrave; stato deciso di utiilizzare la <b>terza opzione</b></li>
        </ol>
        <h3>Sonar</h3>
        Dall'analisi dei requisiti si evince che il
        <kc>Sonar</kc> &egrave; un componente fisico, connesso ad un
        RaspberryPi, il quale genera delle informazioni relative alla distanza da un ostacolo. Per tale motivo
        si pu&ograve; modellare il sonar come un processo che una volta attivato genera informazioni sugli ostacoli.

        <h4>Obiettivo</h4>
        Avere un componente che fornisca la <b>distanza</b> del robot da un ostacolo
        <h4>Problemi</h4>
        Per un'analisi preliminare fare riferimento allo <a
            href="https://htmlpreview.github.io/?https://github.com/LEOB3TA/ColdStorageService-Project/blob/main/Sprint2Reviewed/userDocs/sprint2.html">Sprint2</a>.
        <br><br>
        <b>Problemi attuali:</b>
        <ul>
            <li>Come interagire con il <kc>Sonar fisico</kc></li>
            <li>Come riutilizzare la precedente implementazione del
                <kc>Sonar</kc>
            </li>
        </ul>

        <h4>Possibili soluzioni</h4>
        Il cliente ci ha precedentemente fornito il software per il <b>Sonar</b> (<a
            href="https://github.com/anatali/issLab23/tree/main/unibo.sonarqak23">unibo.sonarqak23</a>) che fornisce un
        implementazione sia per il sonar simulato sia per il sonar fisico.<br>
        Il software &egrave; stato precedentemente <b>modificato</b> nello <a
            href="https://htmlpreview.github.io/?https://github.com/LEOB3TA/ColdStorageService-Project/blob/main/Sprint2Reviewed/userDocs/sprint2.html">Sprint2</a>, quindi &egrave; necessario cambiare solamente l'implmentazione del sonar utilizzando la classe <i>sonarHCSR04Support23</i>.<br>
        Per i dettagli delle interazioni del sonar fisico con l'attore <i>sonar23</i> consultare lo <a
            href="https://htmlpreview.github.io/?https://github.com/LEOB3TA/ColdStorageService-Project/blob/main/Sprint2Reviewed/userDocs/sprint2.html">Sprint2</a>.
        <h3>Basicrobot</h3>
        Il basicrobot &egrave; un componente precedentemente fornito che si occupa di tutto il movimento del transporttrolley, per i dettagli delle interazioni <b>basicrobot-transporttrolley</b> consultare lo <a href="https://htmlpreview.github.io/?https://github.com/LEOB3TA/ColdStorageService-Project/blob/main/Sprint1/userDocs/sprint1.html">Sprint1</a><br>
        <h4>Obiettivo</h4>
        Cambiare l'implementazione del <i>basicrobot</i> da robot virtuale a robot fisico
        <h4>Problemi</h4>
        <ol>
            <li>Creare l'<kc>architettura hardware</kc> su cui fare il deploy del basicrobot</li>
            <li>Conversione dei comandi al <i>wenv</i> in comandi per il robot fisico</li>
            <li>Come fare il <kc>deploy</kc></li>
        </ol>
        <h4>Possibili soluzioni</h4>
        <ol>
            <li>Per la creazione dell'architettura &egrave; necessario analizzare la documentazione fornita insieme al <i>basicrobot</i> che specifica quali componenti avere e come collegarli al <b>RaspberryPi</b> per creare un robot denominato <kc>realnano</kc>.<br> Tale robot contiene anche il supporto hardware per il <i>sonar</i> e per il <i>led</i></li>
            <li>Analizzando la documentazione fornita insieme al <i>basicrobot</i> si evince che il supporto per i movimenti pu&ograve; essere implementato in 3 modi: <b>virtual</b>,<b>realnano</b>,<b>realmbot</b>.<br>
            L'implementazione che interessa a noi &egrave; <kc>realnano</kc>, quindi &egrave; necessario modificare il file di configurazione (<i>basicrobotconfig.json</i>) nel seguente modo:
            <pre>
{"type":"realnano", "port":"8090", "iprobot":"[robotip]", "commtrace": "false"}
            </pre></li>
            <li>Dopo il colloquio con il committente, ci &egrave; stato consegnato il codice sorgente, suggerendoci l'utilizzo del target <kc>Gradle</kc> <i>distZip</i>. Il file ZIP generato deve successivamente essere estratto nell'ambiente <kc>RaspberryPi</kc>, e l'esecuzione del programma deve avvenire mediante il file contenuto nella cartella <i>bin</i>. In aggiunta, &egrave; richiesto il trasferimento di tutti i file di configurazione indispensabili.</li>
        </ol>
        <h3>Modifica dei contesti</h3>
        Tutte le componenti presenti all'interno del <kc>RaspberryPi</kc> devono eseguire in un contesto indipendente dagli altri componenti del sistema.
        <h4>Problemi</h4>
        <ol>
            <li>Come <kc>modificare</kc> il software preesistente in modo che esegua su un <b>RaspberryPi</b>, senza influenzare il comportamento gi&agrave; sperimentato</li>
        </ol>
        <h4>Possibili soluzioni</h4>
        <ol>
            <li>Avendo utilizzato il linguaggio <b>Qak</b> per la precedente implementazione &egrave; sufficiente<ul>
                <li>Creare un progetto <i>Gradle</i> a s&eacute; stante</li>
                <li>Specificare il nuovo contesto su cui eseguir&agrave; il software (<i>ctxrasp</i>) </li>
                <li>Fare il deploy sul computer attraverso un jar</li>
            </ul></li>
        </ol>
        <b>--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------</b>
        <h3>ServiceAccessGUI</h3>
        Dall'analisi dei requisiti si evince che la <kc>ServiceAccessGUI</kc> deve essere eseguita su una computer <b>esterno</b> rispetto all'intero sistema.
        <h4>Problemi</h4>
        <ol>
            <li>Come <kc>modificare</kc> la GUI preesistente in modo che esegua su un computer esterno al sistema, senza influenzare il comportamento gi&agrave; sperimentato</li>
        </ol>
        <h4>Possibili soluzioni</h4>
        <ol>
            <li>Avendo usato <kc>Flutter</kc> che si connette al server <kc>Spring</kc> (considerando che il server eseguir&agrave; sullo stesso computer del CSS) occorre:<ul>
                <li>Modificare l'<b>indirizzo</b> del server a cui si connette la GUI</li>
                <li>Fare la <b>build</b> della GUI</li>
                <li>Fare eseguire la GUI sul dispositivo</li>
            </ul></li>
        </ol>
        <h3>ColdStorageService,TransportTrolley</h3>
        Dall'analisi dei requisiti si evince che questi componenti devon essere eseguiti su un computer a se stante.
        <h4>Problemi</h4>
        <ol>
            <li>Come <kc>modificare</kc> il software preesistente in modo che esegua su un computer esterno al sistema, senza influenzare il comportamento gi&agrave; sperimentato</li>
        </ol>
        <h4>Possibili soluzioni</h4>
        <ol>
            <li>Avendo utilizzato il linguaggio <b>Qak</b> per la precedente implementazione &egrave; sufficiente<ul>
                <li>Creare un progetto <i>Gradle</i> a se stante</li>
                <li>Specificare i nuovi contesti, in particolare: un nuovo contesto per le tre componenti (<i>ctxstorageservice</i>), un contesto per il <b>basicrobot</b> (<i>ctxbasicrobot</i>) e uno per il <b>Raspberry</b> (<i>ctxrasp</i>) con la definizione degli attori <i>external</i></li>
                <li>Fare il deploy sul computer attraverso un container <b>Docker</b>, rendendo pi&ugrave; compatibile il nostro software e rendendo pi&ugrave; facile il deploy nei vari dispositivi.</li>
            </ul></li>
        </ol>
        <h3>ServiceStatusGUI</h3>
        Questo componente pu&ograve; essere eseguito sia nello stesso contesto del <b>CSS</b> che in un contesto esterno
        <h4>Problemi</h4>
        <ol>
            <li>Decidere dove far eseguire la GUI</li>
            <li>Come <kc>modificare</kc> il software preesistente, senza influenzare il comportamento gi&agrave; sperimentato</li>
        </ol>
        <h4>Possibili soluzioni</h4>
        <ol>
          <li>La <kc>GUI</kc> ha possibilit&agrave;:
        <ul>
            <li>Eseguire nello stesso contesto del <b>CSS</b>
            <table style="width:100%" border="1">
                <tr>
                    <td style="width:40%" align="center"><i>PROS</i>
                    </td>
                    <td style="width:40%" align="center"><i>CONS</i>
                    </td>
                </tr>
                <tr>
                    <td>
                        Pi&ugrave; <kc>Economico</kc>
                        per via del costo dell' hardware
                    </td>
                    <td><kc>Maggior carico</kc> su un singolo nodo
                    </td>
                </tr>
                <tr>
                    <td>
                        <kc>Deploy</kc>
                       pi&ugrave; semplice
                    </td>
                    <td>
                        <kc>Minore tolleranza ai guasti</kc>
                    </td>
                </tr>
            </table>
            </li>
            <br>
            <li>Esguire in un contesto diverso
                <table style="width:100%" border="1">
                    <tr>
                        <td style="width:40%" align="center"><i>PROS</i>
                        </td>
                        <td style="width:40%" align="center"><i>CONS</i>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <kc>Separazione</kc>
                            della logica di controllo dalla logica applicativa
                        </td>
                        <td>Necessit&agrave; di fare il
                            <kc>deploy su pi&ugrave; dispositivi</kc>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <kc>Maggiore tolleranza ai guasti</kc>
                        </td>
                        <td>
                            <kc>Maggiore costo</kc>
                            per via del costo dell' hardware
                        </td>
                    </tr>
                </table>
            </li>
            Abbiamo scelto si utilizzare il primo approccio per una questione di comodit&agrave; nel deploy; in futuro se necessario sar&agrave; possibile spostare la GUI su un contesto diverso in modo semplice.
            <br>
            <br>
        </ul>
          </li>
            <li>Avendo usato <kc>Flutter</kc> che si connette al server <kc>Spring</kc> (considerando che il server eseguir&agrave; sullo stesso computer del CSS) occorre:<ul>
                <li>Modificare l'<b>indirizzo</b> del server a cui si connette la GUI</li>
                <li>Fare la <b>build</b> della GUI</li>
                <li>Fare eseguire la GUI sul dispositivo</li>
            </ul></li>
        </ol>
        <h3>ServerSpring</h3>
        Dall'analisi dei requisiti si evince che questo componente deve eseguire sullo stesso contesto del <b>CSS</b>.
        <h4>Problemi</h4>
        <ol>
            <li>Come <kc>modificare</kc> il software preesistente, senza influenzare il comportamento gi&agrave; sperimentato</li>
        </ol>
        <h4>Possibili soluzioni</h4>
        <ol>
            <li>Per garantire la compatibilit&agrave; del software su diversi dispositivi si &egrave; pensato di utilizzare un container <b>Docker</b>, rendendo pi&ugrave; facile il deploy nei vari dispositivi.</li>
        </ol>
    </div>
    <h2>Architettura Logica</h2>
    <br>
   <!-- Modello prototipo: <a style="font-size: larger"
                          href="https://github.com/LEOB3TA/ColdStorageService-Project/blob/main/Sprint2/unibo.prototipo1/src/prototipo1.qak"
                          target="_blank">protipo2.qak</a>
    <br>-->
    <img height="100%" width="100%" src="resources/images/sprint4arch.png" alt="architettura logica"> <br>
</div>


<h2>Project</h2>
<div class="remark">
    Per prima cosa &egrave; stato necessario analizzare il file <a href="https://github.com/LEOB3TA/ColdStorageService-Project/blob/main/Sprint3/unibo.prototipo3/src/prototipo3.qak">prototipo3.qak</a> dividendo gli attori gi&agrave; creati nei contesti finali; per farlo sono stati creati i seguenti file qak:
    <ul>
        <li><a href="https://github.com/LEOB3TA/ColdStorageService-Project/blob/main/Sprint4/unibo.ctxrasp/src/ctxrasp.qak">ctxrasp.qak</a></li>
        <li><a href="https://github.com/LEOB3TA/ColdStorageService-Project/blob/main/Sprint4/coldStorageService/unibo.ctxstorageservice/src/ctxstorageservice.qak">prototipo3.qak</a></li>
    </ul>
    Tutte le ulteriori modifiche effettuate nei vari contesti e nei file associati verranno dettagliate in seguito.
    <h3>RaspberryPi</h3>
    <h3>Led</h3>
    Come indicato nell'<b>Analisi del problema</b> &egrave; stato scelto di utilizzare la libreria <kc>pi4j</kc>.<br>
    Di conseguenza &egrave; stato necessario inserire la dipendenza all'interno del file Gradle.<br>
    A questo punto per garantire <b>versatilit&agrave;</b> del software abbiamo pensato di creare un <kc>oggetto Kotlin</kc> che funga da supporto per il led e cambi il proprio comportamento secondo un file di configurazione, in particolare, all'interno del file <a href="https://github.com/LEOB3TA/ColdStorageService-Project/blob/main/Sprint4/unibo.ctxrasp/ledConfig.json">ledConfig.json</a> &egrave; possibile specificare due tipologie di led:
    <ul>
        <li><b>simulated</b>: in questo caso il supporto stamper&agrave; a video l'output del led</li>
        <li><b>real</b>: in questo caso il supporto attraverso la libreria <kc>pi4j</kc> utilizzer&agrave; i pin <b>GPio</b> per manipolare il led</li>
    </ul>
    All'interno del file <a href="https://github.com/LEOB3TA/ColdStorageService-Project/blob/main/Sprint4/unibo.ctxrasp/resources/ledSupport.kt">ledSupport.kt</a> viene specificata la logica del led; in particolare attraverso la funzione <b>create()</b> viene scelta la tipologia del led e nel caso sia <kc>real</kc> viene creato istanziato il supporto fisico attraveso la <kc>GPiofactory</kc> della libreria <kc>pi4j</kc>.
    Sono disponibili tre funzioni per comandare il led: <b>on()</b>,<b>off()</b>,<b>blink()</b>: ognuna di queste avr&agrave; un comportamento diverso a seconda del tipo di led specificato nel file di configurazione; per completezza viene riportato un esempio: <br>
    <pre>
fun blink(){
    when(ledType){
        "simulated" -> CommUtils.outmagenta("LED BLINKS")
        "real" -> gpioPin.blink(500)
    }
}
    </pre>
    <br>
    A seguito di queste modifiche &egrave; stato necessario modificare il file <b>Qak</b> in modo da sfruttare il nuovo supporto, di conseguenza &egrave; bastato sostituire le print presenti nel vecchio file <b>Qak</b> con le chiamate al supporto per il led.
    <h3>Sonar</h3>
    Considerando il software precedentemente fornito &egrave; bastato modificare leggermente il file <b>ctxrap.qak</b> utilizzando come <i>CodedQActor</i> <kc>rx.sonarHCSR04Support23</kc>.
    <pre>
CodedQActor sonar  context ctxrasp className "rx.sonarHCSR04Support23"
    </pre>
    <b>--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------</b>
    <h3>ServiceAccessGUI</h3>
    Per modificare l'indirizzo del server &egrave; stato necessario modificare il file <a href="https://github.com/LEOB3TA/ColdStorageService-Project/blob/8ca7cfc071998b7c769ead0fddfa3dd8d0f7bcb0/Sprint4/serviceaccessgui/lib/service/ws_service.dart">ws_service.dart</a>.
    <pre>
class WsService {
  static const socketUrl = 'ws://'server-ip':11804/ws-message'; // if in another pc
}
    </pre>
    </ol>
    <h3>ColdStorageService,TransportTrolley</h3>
    Dopo aver creato il file <kc>Qak</kc> a se stante, &egrave; stato necessario creare un jar tramite il target Gradle <i>shadowJar</i>, per poi inserirlo all'interno di un container <kc>Docker</kc> per garantire il massimo della compatibilit&agrave;.<br>
    Utilizzando l'immagine di base <i>openjdk:11</i> vengono copiato tutti i file di configurazione e il file jar che viene poi eseguito.
    Di seguito viene riportato il contenuto di <a href="https://github.com/LEOB3TA/ColdStorageService-Project/blob/81d7136b3de551da11757feb65fed79b14966d3d/Sprint4/release/coldStorageService/DockerfileCSS">DockerfileCSS</a>.
    <pre>
FROM openjdk:11

VOLUME /tmp
COPY ./ctxstorageservice.pl ctxstorageservice.pl
COPY ./sysRules.pl sysRules.pl
COPY ./Californium3.properties Californium3.properties
COPY ./unibo.ctxstorageservice-1.0-all.jar css.jar
ENTRYPOINT ["java", "-jar", "/css.jar"]
    </pre>
    <h3>ServerSpring</h3>
    Dopo aver creato il jar tramite il target Gradle <i>bootJar</i>, &egrave;  stato inserito all'interno di un container <kc>Docker</kc> per garantire il massimo della compatibilit&agrave;.<br>
    Utilizzando l'immagine di base <i>openjdk:11</i> viene copiato file jar che viene poi eseguito.
    Di seguito viene riportato il contenuto di <a href="https://github.com/LEOB3TA/ColdStorageService-Project/blob/81d7136b3de551da11757feb65fed79b14966d3d/Sprint4/release/coldStorageService/DockerfileSpring">DockerfileSpring</a>.
    <pre>
FROM openjdk:11

VOLUME /tmp
COPY ./servicestatusbe.jar be.jar
ENTRYPOINT ["java", "-jar", "/be.jar"]
    </pre>
</div>
<h2>Testing TODO</h2>
<div class="remarkTest">
    Al fine di testare il corretto funzionamento dei nuovi componenti sviluppati per la simulazione del
    comportamento di sonar e led &egrave; stato sviluppato un file <a
        href="https://github.com/LEOB3TA/ColdStorageService-Project/blob/main/Sprint2Reviewed/unibo.prototipo2/src/test.qak">test.qak</a>,
    contenente i componenti necessari ed una suite di <a
        href="https://github.com/LEOB3TA/ColdStorageService-Project/blob/main/Sprint2Reviewed/unibo.prototipo2/src/test/it/unibo/TestPrototipo2.kt">test </a>,
    nella quale si verifica il corretto funzionamento dei nuovi componenti aggiunti.<br>
    In particolare si verifica che:
    <ul>
        <li> All'inizio il Led sia Spento, in quanto il robot &egrave; in HOME</li>
        <li> Nel momento in cui il robot inizia a muoversi il Led lampeggia</li>
        <li> Quando il robot riceve una Stop il Led si Accende</li>
    </ul>
    per quanto concerne il Led. Per quanto riguarda i dati forniti dal sonar:
    <ul>
        <li>Ignorare gli Stop che arrivano in un tempo inferiore a MINT millisecondi rispetto all'ultimo ricevuto</li>
        <li>Fermare il robot dopo uno Stop ricevuto fino al ricevimento del prossimo Resume</li>
    </ul>
</div>
<h2>Avviare il sistema</h2>
<div class="remark">
    <h3>Avvio automatizzato</h3>
    <h5>Robot</h5>

    Scaricare l'ultima release da <b>Github</b>, utilizzare lo script adeguato per il proprio sistema:
    <ul>
        <li>Linux: <b>startPrototype-linux.sh</b></li>
        <li>MacOS: <b>startPrototype-mac.sh</b></li>
        <li>Windows: <b>startPrototype-win.bat</b></li>
    </ul>

    <h5>Avvio manuale</h5>

    <ol>
        <li style="font-size: 25px">
            <em style="font-size: 25px">Avviare il
                <bc>WebRobot23</bc>
            </em>
            <p style="font-size: 16px">In tal modo si avviano il <i>basicrobot23</i> ed il <i>wenv</i></p>
            <pre style="font-size: 16px">
cd ColdStorageService-Project/Sprint1/unibo.basicrobot23
docker-compose -f webbasicrobot23.yaml up</pre>
        </li>
        <li style="font-size: 25px">
            <em style="font-size: 25px">Avviare il
                <bc>ColdStorageService</bc>
                ,
                <bc>MockTruck</bc>
                e
                <bc>Transporttrolley</bc>
            </em>
            <p style="font-size: 16px">In tal modo si avviano le varie componenti</p>
            <pre style="font-size: 16px">
cd ColdStorageService-Project/Sprint2Review/unibo.prototipo2
./gradlew run</pre>
        </li>
    </ol>
</div>

<!--
            <h2>Maintenance</h2>
            -->
<!-- USEFUL
<table style="width:100%" border="1">
<tr>
<td style="width:40%">
</td>
<td></td>
</tr>
</table>
-->

<br/><br/>
</div>

<div class="stud">
    By Students: <br/>
    <div class="studentCardRow">
        <div class="studentCard">
            <div class="studentName">Leonardo Focardi</div>
            <div class="studentEmail"><a
                    href="mailto:leonardo.focardi@studio.unibo.it">leonardo.focardi@studio.unibo.it</a>
            </div>
            <div class="studentImg"><img class="studentAvatar" src="./resources/boys/leo.jpg"></div>
        </div>
        <div class="studentCard">
            <div class="studentName">Christian Galeone</div>
            <div class="studentEmail"><a href="mailto:christian.galeone@studio.unibo.it">christian.galeone@studio.unibo.it</a>
            </div>
            <div class="studentImg"><img class="studentAvatar" src="./resources/boys/christian.jpg"></div>
        </div>
        <div class="studentCard">
            <div class="studentName">Gianmiriano Porrazzo</div>
            <div class="studentEmail"><a href="mailto:gianmiriano.porrazzo@studio.unibo.it">gianmiriano.porrazzo@studio.unibo.it</a>
            </div>
            <div class="studentImg"><img class="studentAvatar" src="./resources/boys/gian.jpg"></div>
        </div>
    </div>

    <div class="repo">
        GIT repo: <a href="https://github.com/LEOB3TA/ColdStorageService-Project">https://github.com/LEOB3TA/ColdStorageService-Project</a>
    </div>
</div>
</body>
</html>