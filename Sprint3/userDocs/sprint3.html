<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<!--
<script type="text/javascript" src="../css/issStyle.js"></script>
-->
<link rel="stylesheet" type="text/css" href="resources/css/sprint0.css">

<head>

    <title>Sprint3</title></head>

<body>
<!--
<div id="top">
    <h1><b>PROGETTO DI INGEGNERIA DEI SISTEMI SOFTWARE</b> - SPRINT 0 <font size="5"></font></h1>
    <h3>Gruppo di lavoro: Focardi, Galeone, Porrazzo <font size="3"></font></h3>
</div>
-->
<div class="body">
    <h2>Introduction</h2>
    <div class="remark"> Progetto finale di ISS, finalizzato allo sviluppo software di un magazzino refrigerato, nel
        quale
        vi &egrave; un robot che ha il compito di trasportare del cibo da un punto di partenza - chiamato INDOOR - alla cella
        frigorifera.
    </div>
    <a href="https://htmlpreview.github.io/?https://github.com/LEOB3TA/ColdStorageService-Project/blob/main/Sprint2Reviewed/userDocs/sprint2.html">Sprint2 </a>

    <h2>Requirements</h2>
    <div class="remark">
        <a href="https://htmlpreview.github.io/?https://github.com/anatali/issLab23/blob/main/iss23Material/html/TemaFinale23.html">Tema Finale </a>
    </div>
    <h3>Goal</h3>
    <div class="remark">
        In questo sprint ci siamo focalizzati sulla creazione delle <kc>Gui</kc> per consentire agli utenti
        o al manager di osservare lo stato attuale ed interagire col robot.<br>
        In particolare si vogliono soddisfare i requisiti indicati per la <kc>ServiceAccessGUI</kc>, usata dai
        clienti, e per la <kc>ServiceStatusGUI</kc>, utilizzata da un <b>Service-manager</b>, come specificati
        nei <a href="https://htmlpreview.github.io/?https://github.com/anatali/issLab23/blob/main/iss23Material/html/TemaFinale23.html">requisiti</a>.<br>
        Dunque il prodotto finale di questo sprint consiste in due GUI:<br><br>
        <ul>
            <li>ServiceAccessGUI</li>
            <li>ServiceStatusGUI</li>
        </ul>

    </div>
    <h3>Work plan</h3>
    <div class="remark">
        Partendo dal software realizzato per lo <a href="https://htmlpreview.github.io/?https://github.com/LEOB3TA/ColdStorageService-Project/blob/main/Sprint2Reviewed/userDocs/sprint2.html">Sprint2 </a>
        realizzare le <kc>GUI</kc>, tenendo conto di:
        <ul>
            <li>
                Come collegare e far comunicare i vari componenti
            </li>
            <li>
                Come e quali dati devono essere inviati a quale GUI
            </li>
            <li>
                Tipo di GUI da realizzare
            </li>
        </ul>
    </div>

    <h2>Problem analysis</h2>
    <div class="remark">
        <h3>Tipo di GUI da realizzare</h3>
        <div>
            Per sviluppare le GUI possiamo usare:
            <ul>
                <li>Web App</li>
                <li>App per vari devices</li>
            </ul>

        Siccome nei requisiti non sono presenti preferenze e/o limitazioni a riguardo, ed essendo
        lo sviluppo di applicazioni per dispositivi mobili strettamente legato alla tipologia di dispositivi,
        si consiglia la realizzazione varie versioni dell'applicazione, per device che usano Linux, Windows o MacOs.
        </div>
    </div>
    <h3>Dati</h3>
    <div class="remark">
        Dai requisiti si pu&ograve; notare che la <kc>ServiceStatusGUI</kc> deve essere in grado di
        mostrare ad un <kc>Service-manager</kc> una serie di informazioni riguardanti lo stato del
        sistema e dei suoi componenti. Sempre dai requisiti, si evince che anche la <kc>ServiceAccessGUI</kc>
        deve fornire una serie di informazioni riguardanti il sistema e lo stato della richiesta presa in carico.
        Oltre a ci&ograve;, quest'ultima GUI deve essere in grado di prendere delle informazioni dall'utente.
        Per tali motivi bisogna comprendere quali sono le sorgenti di dati che servono per aggiornare le GUI.
        <h4>Sorgenti di Dati</h4>
            Le principali fonti da cui le GUI prendono dati sono legate alle informazioni che tali interfacce grafiche
            devono mostrare:
            <ul>
                <li>
                    Stato del <kc>TransportTrolley</kc> e sua posizione nella stanza (solo ServiceStatusGUI)
                </li>
                <li>
                    Peso presente attualmente nella <kc>ColdRoom</kc>
                </li>
                <li>
                    Numero di richieste di deposito rifiutate (solo ServiceStatusGUI)
                </li>
                <li>
                    Ticket rilasciato dal servizio (solo ServiceAccessGUI)
                </li>
            </ul>
            Inoltre &egrave; importante sottolineare come la ServiceAccessGUI sia anche una sorgente di
            dati, in quanto consente al cliente di indicare la quantit&agrave; di cibo da depositare e, successivamente,
            il ticket number per avviare il processo di deposito.

            <h6>Stato TransportTrolley</h6>
            In seguito all'analisi dei requisiti e all'analisi condotta nello Sprint1 &egrave; stato deciso di rappresentare
            lo Stato del TransportTrolley come una <em>data class Kotlin</em>, in cui sono presenti le rappresentazioni,
            mediante l'uso di enumerativi, dello stato attuale e della posizione attuale del TransportTrolley.
<!--            // TODO:link e code-->

            <h6>Stato ColdStorageService</h6>
            Analogamente per quanto accade con il TransportTrolley, &egrave; stato creata una data class Kotlin
            per contenere le informazioni relative alla ColdRoom e allo stato generale del servizio (<i>Richieste rifiutate,
        peso attuale/totale, ...</i>). Anche queste scelte sono state commentate precedentemente.

            Per gestire entrambi gli stati si utilizzano dei CoapObserver: in tal modo ogni qual volta si presenti
            una modifica dei dati d'interesse viene emesso un Update che pu&ograve; essere utilizzato per trasmettere
            i nuovi dati alle GUI.
            <h4>Pulling vs Push</h4>
            Compreso come i dati vengono generati per arrivare alle GUI, bisogna comprendere come
            essi vengano effettivamente recuperati dalle GUI.<br> Sono possibili due modelli:
            <h6>Polling</h6>
            In questo modello la GUI richiede all'attore i dati, dunque la GUI deve aprire un canale
            con tale attore, richiedere i dati e rimanere in ascolto delle risposte.<br>
            Inoltre per non perdere nessun dato, tale azione dovrebbe essere compiuta ad intervalli regolari,
            aumentando l'overhead di rete. Per tale motivo questa soluzione &egrave; sconsigliata.
            <h6>Push</h6>
            Questa soluzione prevede, invece, che la GUI rimanga in attesa di update e li mostri all'utente.
            Per implementare tale modello, si necessita di un componente che recepisca gli aggiornamenti dello
            stato e li invii alle GUI.<br>
            Tale soluzione &egrave; quella consigliata, in quanto consente di sfruttare le caratteristiche degli
            attori QAk di essere realizzati come risorse CoAP, ovvero osservabili.<br>
            Procedendo in tal modo, sar&agrave; possibile inviare gli aggiornamenti mediante la creazione di una
            connessione CoAP fra server e l'attore che gestisce gli update e che questo si registri come osservatore
            della risorsa (o delle risorse ) di interesse. In tal modo ogni volta che le risorse saranno modificate
            da un updateResource, il server CoAP recepisce il messaggio e manda gli update alle GUI notificando il
            cambiamento dello stato.
        </div>

    <h3>Comunicazione tra i vari componenti in gioco</h3>
    <div class="remark">
        Come gi&agrave; accennato dal punto precedente, una parte importante &egrave; della realizzazione &egrave; legata
        alla gestione delle comunicazioni tra i vari componenti. In generale si vuole ottenere un comportamento che
        segua tale modello:
        <ul>
            <li>
                <kc>ServiceStatusGUI</kc>: Questa GUI &egrave; <italic>passiva</italic>, rimane in attesa degli update,
                eccezion fatta per il primo collegamento, nel quale &egrave; la GUI stessa ad inviare un "segnale" per
                indicare che vuole ricevere i dati pi&ugrave; aggiornati anche se non sono presenti update dello stato.
            </li>
            <li>
                <kc>ServiceAccessGUI</kc>: Questa GUI implementa il modello precedente per quanto riguarda la gestione
                dei dati relativi allo stato, ma ha anche una componente di dati da inviare, per tale motivo deve essere presente
                anche una parte relativa all'invio di richieste e gestione di risposte.
            </li>
        </ul>
    </div>


    <h2>Architettura Logica</h2>
    <div class="remark">
        Di seguito si riporta l'architettura logica relativa al <a style="font-size: larger" href="https://github.com/LEOB3TA/ColdStorageService-Project/blob/main/Sprint3/unibo.prototipo3/src/prototipo3.qak" target="_blank">protipo3.qak</a>. <br>
        <figure>
            <img height="100%" width="100%" src="./resources/images/prototipo3arch.png" alt="architettura logica"> <br>
            <figcaption>
                Nota: nella figura precedente sono stati rimossi gli attori relativi al sonar per ottenere una figura compatta
            </figcaption>
        </figure>
        Di seguito viene riportata l'architettura contenete informazioni relative a tutti i componenti in gioco.
        <img height="100%" width="100%" src="./resources/images/iss.png" alt="architettura logica"> <br>
        Nella precedente figura sono stati appositamente omessi alcuni dettagli, in quanto il focus principale &egrave; relativo al comportamento
        d'insieme dei vari componenti e di come le varie connessioni interagiscano
    </div>


    <h2>Project</h2>
    <div class="remark">
        <h3>guicontroller</h3>
            <div>
                Come introdotto nella parte di Analisi del Problema, si necessita di un componente in grado di osservare
                lo stato delle risorse di interesse ed invii gli update di conseguenza. Tale componente &egrave; il
                guicontroller. Il guicontroller &egrave; un attore che controlla tutte le interazioni con le gui:
                dall'invio degli update, alla gestione delle richieste.<br>
                <pre>
<key2>Dispatch</key2> updateS: updateS(W) // W = peso
<key2>Disptach</key2> getData:getData(_)
<key2>Dispatch</key2> updateR:updateR(_)
                </pre>
                In particolare questo controller osserva le due risorse di interesse, ovvero lo stato del TransportTrolley e
                quello del ColdStorageService, ed aggiorna lo stato relativo alla GUI di conseguenza. Ci&ograve; permette
                che ogni volta che il <kc>guicontroller</kc> riceve un <pro>updateResource</pro>, possa gestire l'aggiornamento
                e aggiornare lo
                <a style="font-size: larger" href="https://github.com/LEOB3TA/ColdStorageService-Project/blob/main/Sprint3/unibo.prototipo3/resources/state/GuiState.kt" target="_blank">stato della gui</a>.
                <br>
                In tal modo, essendo presente nel back-end un observer che rileva gli update per le gui ed, in base a vari criteri,
                sceglie a chi mandare cosa.
            </div>

        <h3>Realizzazione Back-end</h3>
            <div>
                Per la realizzazione del Back-end si &egrave; deciso di usare Java Spring, in quanto il team possedeva le
                conoscenze necessarie ad usarlo.<br>
                Il Back-end &egrave; il componente che si occupa di smistare le richieste alle GUI giuste e ai clienti giusti
                (nel caso di pi&ugrave; clienti collegati simultaneamente). Per tale motivo questo gestisce le connessioni tra i vari componenti.<br>
                Lato attori viene creato una connessione CoAP ed una TCP, in tal modo si riesce ad interfacciare con l'attore descritto nel punto precedente.<br>
                <pre>
 <key>private static final String</key> ctxName = "ctxprototipo3";
 <key>private static final String</key> actorGui = "guicontroller";

 <key>public CoapConnection</key> connectCoap(<key>String</key> ip, <key>int</key> port) {
        try {
            <key>String</key> path = ctxName + "/" + actorGui;
            conn = <key>new</key> CoapConnection(ip + ":" + port, path);
            ColorsOut.out("[UtilsStatusGUI] connect Tcp conn:" + conn);
                ...
         }
        <key>return</key> (CoapConnection) conn;
    }
  <key>public void</key> connectTCP(<key>String</key> ip, <key>int</key> port) {
        try {
            CommSystemConfig.tracing = true;
            connTCP = TcpClientSupport.connect(ip, port, 10);
            ColorsOut.out("[UtilsStatusGUI] connect Tcp conn:" + conn);
                ...
        }
    }
                </pre>
                La connessione CoAP &egrave; utile per gestire gli eventi di modifica dello stato in modo da non caricare troppo la rete, mentre la connessione
                TCP serve per gestire i messaggi diretti.
                <br>
                In paritcolare si riporta di seguito un estratto dell'observer.
                <pre>
    <key>public class</key> UtilsCoapObserver <key>implements</key> CoapHandler {

    @Override
    <key>public void</key> onLoad(<key>CoapResponse</key> response){
        ColorsOut.outappl("UtilsCoapObserver changed!" + response.getResponseText(), ColorsOut.GREEN);
        WebSocketController.sendToAll(""+response.getResponseText());
    }
    @Override
    <key>public void</key> onError() {

    }
}
                </pre>
                Il quale viene poi richiamato al momento della creazione della connessione CoAP.<br><br>
                Per quanto riguarda le GUI si &egrave; deciso di usare le <kc>WebSocket</kc>. Il motivo principale di questa scelta &egrave; dovuto alla natura
                asincrona di questa tecnologia ( ottima per gestire gli update ), ma che garantisce la distinzione dei vari client in base a degli ID univoci.
                In particolare per la gestione degli update dello stato sono state creati dei topic, per via del fatto che si ha una comunicazione one-to-many, in
                cui gli interessati si iscrivono al topic:
                <pre>
<key>public void</key> handleSubscribeEvent(<key>SessionSubscribeEvent</key> event) {
        ...

        <key>switch</key> (destination) {
            <key>case</key> "/topic/updates":
                sessionList.add(sessionId);
                System.out.println("Session Id" + sessionId + " subscribed to " + destination);
                ...
                template.convertAndSend("/topic/updates", weightDTO);
                <key>break</key>;
            <key>case</key> "/topic/status":
                System.out.println("Session subscribed to " + destination);
                ...
                template.convertAndSend("/topic/status", serviceConfigDTO.toJson());
                <key>break</key>;
        }
    }
                </pre>
                Come si pu&ograve; osservare dal codice riportato sono presenti <b>due</b> topic invece di <b>uno</b>. Tale scelta &egrave; stata fatta a
                seguito di un'accurata riflessione sul fatto che non vogliamo che gli update relativi ad una gui raggiungano l'altra gui, o meglio siccome
                le gui richiedono due update diversi, in base alle richieste commissionate, si &egrave; pensato di distinguere le tipologie di update.
                Ci&ograve; per garantire la separazione dei dati.<br><br>
                Per quanto riguarda i canali relativi allo scambio di messaggi, sono stati utilizzati delle queue private in modo che ogni utente riceva il
                messaggio di risposta che si attende, senza interferire con gli altri clienti.
                <pre>
           <key>case</key> "/user/queue/store-food":
                //sessionList.add(sessionId);
                System.out.println("Session Id" + sessionId + " subscribed to " + destination);
                assert sessionId != null;
                template.convertAndSendToUser(sessionId, "/queue/responses");
                <key>break</key>;
           <key>case</key> "/user/queue/deposit":
                System.out.println("Session Id" + sessionId + " subscribed to " + destination);
                assert sessionId != null;
                template.convertAndSendToUser(sessionId, "/queue/responses");
                <key>break</key>;
           </pre>
            Oltre a questa dichiarazione delle queue e dei topic si &egrave; proseguito con l'implementazione della logica.
            Per una pi&ugrave; dettagliata visione sulla logica rimandiamo al componente che se ne occupa:
            <a style="font-size: larger" href="https://github.com/LEOB3TA/ColdStorageService-Project/blob/main/Sprint3/servicestatusbe/src/main/java/com/unibo/servicestatusbe/websocket/WebSocketMessageConfig.java" target="_blank">WebSocketController</a>.
            </div>

        <h3>Realizzazione GUI (front-end)</h3>
            <div>
                Per la realizzazione delle GUI in quanto tali, si &egrave; deciso di usare Flutter, in quanto i componenti del team hanno
                esperienza con tale tecnologia.<br>
                Nel punto precedente si &egrave; affermato come le <kc>WebSocket</kc> siano state scelte per la natura asincrona, ci sono
                tuttavia casi in cui si necessita di un comportamento sincrono.<br>
                Ad esempio quando un cliente invia una richiesta di deposito, questo deve attendere la valutazione della richiesta prima di poter
                effettuare i successivi passaggi. Per tale motivo si &egrave; deciso di attivare punto successivo della sequenza solo
                quando si riceve una risposta alla nostra richiesta e questa &egrave; una risposta affermativa.
                <img height="100%" width="100%" src="./resources/images/serviceAccess.png" alt="ServiceAccess"> <br>
                <br>
                Da come si pu&ograve; osservare nella figura &egrave; presente uno stepper che ha il compito di abilitare all'azione
                successiva, solo dopo che si &egrave; ricevuta una risposta. Inoltre, una volta effettuata un'azione non si pu&ograve; tornare indietro.
                <br><br>
                <img height="100%" width="100%" src="./resources/images/serviceStatus.png" alt="ServiceStatue"> <br>
                <br>
                Nella ServiceStautsGUI si possono osservare:
                <ul>
                    <li>
                        Il peso corrente nella <kc>ColdRoom</kc>
                    </li>
                    <li>
                        Lo stato attuale del <kc>TransportTrolley</kc>, con relativa posizione
                    </li>
                    <li>
                        Il numero di ticket emessi, ma rifiutati dal sistema.
                    </li>
                </ul>
                <h6>Gestione comunicazioni</h6>
                Per quanto riguarda la gestione delle <kc>WebSocket </kc> lato <i>front-end</i>, bisogna distinguere le due gui, in quanto:
                <ul>
                    <li>
                        La ServiceStatusGUI deve iscriversi al <kc>topic status</kc> per ricevere gli update
                    </li>
                    <li>
                        La ServiceAccessGUI si iscrive al <kc>topic updates</kc> e alle <k>queue store-food e deposit</k>
                     </li>
                </ul>
                In entrambi i casi per&ograve; si necessita prima di connettersi alla websocket.
                <pre>

  void stompClientConfig() {
    stompClient = StompClient(
      config: StompConfig(
        url: widget.url,
        onConnect: socketConnection,
       ...
        },
        onDisconnect: (dynamic frame) {
          logger.i('WebSocket Info: Disconnected.');
        },
      ),
    );

    stompClient.activate();
  }
                </pre>
                In seguito ogni GUI si iscrive ai topic/queue di interesse
                <pre>
 void socketConnection(StompFrame frame) {
    print(frame.headers);
    //comment
    stompClient.subscribe(
        destination: '/topic/message',
        headers: {'id': id},
        callback: (StompFrame frame) {
         ...
        });
    stompClient.subscribe(
        destination: '/topic/updates',
        callback: (StompFrame frame) {
          ...
        });
    stompClient.subscribe(
        destination: '/user/queue/store-food/$id',
        ...
        });
    stompClient.subscribe(
        destination: '/user/queue/deposit/$id',
       ...
        });
                </pre>
                Per la ServiceAccess, e
                <pre>
void onConnect(StompFrame frame) {
    stompClient.subscribe(
      destination: '/topic/status',
     ...
      }
    );
    ...
    setState(() {
      isLoading = false;
    });
  }
                </pre>
                per la ServiceStatus.<br><br>
                A seguito di ci&ograve; sono state implementate delle funzioni di <b>callback</b> per gestire la logica di funzionamento, una volta che si invia/riceve un messaggio/update.
                <!--                Ora tale appunto &egrave; pi&ugrave; una questione di principio che di attuazione pratica siccome gli update e le request sono immediati, ma immaginando condizioni estreme ci siamo imbattuti in tale problematica-->
            </div>
    </div>

<!--    <h2>Testing</h2>-->
<!--    <div class="remark">-->


<!--            </div>-->

    <h2>Piano di lavoro</h2>
    <div class="remark">
        Tutti gli sprint sotto intendono delle migliorie e delle eventuali modifiche del lavoro fatto negli sprint precedenti

        <h3>Sprint 4</h3>
        Deploy sul raspberry:
        <ul>
            <li>Creazione del supporto per led fisico</li>
            <li>Deploy del sonar</li>
            <li>Deploy del basic robot</li>
        </ul>

    </div>

    <h2>Avviare il sistema</h2>
    <div class="remark">
        <h5>Avvio automatizzato</h5>

        Scaricare l'ultima release da <b>Github</b>, utilizzare lo script adeguato per il proprio sistema:
        <ul>
            <li>Linux: <b>startPrototype-linux.sh</b></li>
            <li>MacOS: <b>startPrototype-mac.sh</b></li>
            <li>Windows: <b>startPrototype-win.bat</b></li>
        </ul>

        <h5>Avvio manuale</h5>

        <ol >
            <li style="font-size: 25px">
                <em style="font-size: 25px">Avviare il <bc>WebRobot23</bc></em>
                <p style="font-size: 16px">In tal modo si avviano il <i>basicrobot23</i> ed il <i>wenv</i></p>
                <pre style="font-size: 16px">
cd ColdStorageService-Project/Sprint1/unibo.basicrobot23
docker-compose -f webbasicrobot23.yaml up</pre>
            </li>
            <li style="font-size: 25px">
                <em style="font-size: 25px">Avviare il <bc>ColdStorageService</bc>,<bc>guicontroller</bc> e <bc>Trasporttrolley</bc></em>
                <p style="font-size: 16px">In tal modo si avviano le varie componenti</p>
                <pre style="font-size: 16px">
cd ColdStorageService-Project/Sprint3/unibo.prototipo3
./gradlew run</pre>
            </li>
            <li style="font-size: 25px">
                <em style="font-size: 25px">Avviare il <bc>Back end</bc></em>
                <p style="font-size: 16px">In tal modo si avvia il server</p>
                <pre style="font-size: 16px">
cd ColdStorageService-Project/Sprint3/backend
./gradlew bootRun</pre>
            </li>
            <li style="font-size: 25px">
                <em style="font-size: 25px">Avviare la <bc>ServiceStatusGUI</bc> o la <bc>ServiceAccessGUI</bc> </em>
                <p style="font-size: 16px">In tal modo si avviano le GUI. Per usare le gui in questo modo si necessita di aver installato una sdk di
                    <a href="https://docs.flutter.dev/get-started/install">fluttern </a>

                </p>
                <pre style="font-size: 16px">
cd ColdStorageService-Project/Sprint3/ServiceAccessGUI
                    o
cd ColdStorageService-Project/Sprint3/ServiceStatusGUI
./flutter run</pre>
            </li>
        </ol>
            </div>

    <!--
                <h2>Maintenance</h2>
                -->
    <!-- USEFUL
    <table style="width:100%" border="1">
    <tr>
    <td style="width:40%">
    </td>
    <td></td>
    </tr>
    </table>
    -->

    <br/><br/>
</div>

<div class="stud">
    By Students: <br/>
    <div class="studentCardRow">
        <div class="studentCard">
            <div class="studentName">Leonardo Focardi</div>
            <div class="studentEmail"><a href= "mailto:leonardo.focardi@studio.unibo.it">leonardo.focardi@studio.unibo.it</a>
            </div>
            <div class="studentImg"><img class="studentAvatar" src="./resources/boys/leo.jpg"></div>
        </div>
        <div class="studentCard">
            <div class="studentName">Christian Galeone</div>
            <div class="studentEmail"><a href= "mailto:christian.galeone@studio.unibo.it">christian.galeone@studio.unibo.it</a></div>
            <div class="studentImg"><img class="studentAvatar" src="./resources/boys/christian.jpg"></div>
        </div>
        <div class="studentCard">
            <div class="studentName">Gianmiriano Porrazzo</div>
            <div class="studentEmail"><a href= "mailto:gianmiriano.porrazzo@studio.unibo.it">gianmiriano.porrazzo@studio.unibo.it</a></div>
            <div class="studentImg"><img class="studentAvatar" src="./resources/boys/gian.jpg"></div>
        </div>
    </div>

    <div class="repo">
        GIT repo: <a href="https://github.com/LEOB3TA/ColdStorageService-Project">https://github.com/LEOB3TA/ColdStorageService-Project</a>
    </div>
</div>
</body>
</html>